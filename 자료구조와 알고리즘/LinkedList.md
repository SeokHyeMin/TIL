## 연결리스트(LinkedList)
- 연결리스트는 배열과 마찬가지로 항목의 리스트를 표현하는 자료구조이다.
- 연결리스트는 나란히 이어진 셀의 묶음이 아닌 서로 인접하지 않은 메모리 셀 묶음으로 이뤄진다.
- 서로 인접하지 않은 이러한 셀을 **노드**라고 부른다.

### 노드
- 컴퓨터는 인접해 있지 않은 노드들이 같은 연결 리스트에 속하는지 어떻게 알 수 있을까?
    - 노드는 노드에 저장된 데이터 뿐만 아니라 연결리스트 내에 다음 노드의 메모리 주소도 저장하기 때문에 위의 의문이 해결된다.

~~~java
class Node{
        int data;
        Node next_node = null;
}
~~~
- 노드 클래스에는 속성이 두 가지 있다.
- 노드에 저장해야하는 값인 data와 리스트 내 다음 노드의 링크인 next_node이다.

✔️ [연결리스트 구현 코드](https://github.com/SeokHyeMin/TIL/blob/main/자료구조와%20알고리즘/Code/LinkedListNode.java)
- 연결 리스트의 읽기와 검색의 효율성은 O(N)이다.
- 하지만 연결 리스트의 삽입 효율성은 O(1)이다.  
    - 그 전의 노드가 새로 삽입할 노드의 링크를 가리키게 해주면 되기 때문.
    - 배열처럼 나머지 값들을 이동할 일이 없다.
- 삭제도 삽입과 마찬가지로 효율성은 O(1)이다.
- 배열과 큰 차이가 없어보이지만 연결리스트가 빛을 발하는 경우는 한 리스트를 검사해서 많은 원소를 삭제하는 경우이다.

### 이중 연결리스트
- 각 노드에 2개의 링크가 있다는 점을 제외하면 연결 리스트와 비슷하다.
- 한 링크는 다음 노드를 가리키고, 다른 한 링크는 **앞 노드**를 가리킨다.
- 큐를 이중 연결리스트를 이용해서 구현하면 삽입과 삭제를 모두 O(1)에 할 수 있다.

### LinkedList 관련 알고리즘 문제
- 정렬되지 않은 LinkedList에서 중복값 삭제
    - 버퍼사용 O
        - 공간복잡도 O(n), 시간복잡도 O(n)
    - [버퍼사용 X](https://github.com/SeokHyeMin/TIL/blob/main/자료구조와%20알고리즘/Code/LinkedListNode.java#L47)
        - 공간복잡도 O(1), 시간복잡도 O(n<sup>2</sup>)

- 단방향 LinkedList의 끝에서 k번째 노드를 찾는 알고리즘
    - 방법1 : 연결리스트를 처음부터 끝까지 가면서 길이를 알아낸 후, 길이에서 찾고자 하는 인덱스의 값을 빼주고 1을 더해 원하는 값을 찾는 방법.
        - 1을 더하는 이유는 k가 1일때 맨 뒤의 노드를 꺼내도록 코드를 구현할 것이기 때문에 이를 생각하여 1을 더해주어야한다.
    - 방법2 : [재귀호출을 사용하여 해결](https://github.com/SeokHyeMin/TIL/blob/main/자료구조와%20알고리즘/Code/LinkedListNode.java#L78)
    - [방법3 : 포인터를 이용하여 해결](https://github.com/SeokHyeMin/TIL/blob/main/자료구조와%20알고리즘/Code/LinkedListNode.java#L91)
        - p1,p2가 있을 때 p1을 p2보다 k만큼 뒤에 위치시키고, 각각 한 칸 씩 서로 이동하면p1이 null을 만났을 때(맨 끝 다음) p2는 뒤에서 k번째 노드에 위치하게 된다.
    
- 단방향 LinkedList에서 [중간에 있는 노드를 삭제](https://github.com/SeokHyeMin/TIL/blob/main/자료구조와%20알고리즘/Code/LinkedListNode.java#L108)하시오.
(단, 첫번째 노드가 어딨는지 모르고, 오직 삭제할 노드만 갖고 있다.)
    - 삭제할 노드의 다음 노드를 삭제할 노드와 같게 만들어주고 그 다음 노드를 삭제하면 된다.

- LinkedList에 있는 노드들을 x값을 기준으로 값이 작은 것들은 왼쪽, 큰것들은 오른쪽으로 나누기(왼, 오만 나누지 그 안에서 하나하나 정렬하는것은 아님)
    -  x값은 오른쪽에서 제일 앞에 있어야하는 것은 아니다.
    - [방법1 : 두 줄로 나눠서 해결하기.](https://github.com/SeokHyeMin/TIL/blob/main/자료구조와%20알고리즘/Code/LinkedListNode.java#L121)
    - [방법2 : 앞뒤로 붙이기](https://github.com/SeokHyeMin/TIL/blob/main/자료구조와%20알고리즘/Code/LinkedListNode.java#L157)
        - 위의 방법은 포인터가 4개이므로 단순하게 여기서는 포인터를 2개만 사용해서 사용한다.
<br><br>
참조 : 누구나 자료구조와 알고리즘
