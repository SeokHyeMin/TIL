## 연결리스트(LinkedList)
- 연결리스트는 배열과 마찬가지로 항목의 리스트를 표현하는 자료구조이다.
- 연결리스트는 나란히 이어진 셀의 묶음이 아닌 서로 인접하지 않은 메모리 셀 묶음으로 이뤄진다.
- 서로 인접하지 않은 이러한 셀을 **노드**라고 부른다.

### 노드
- 컴퓨터는 인접해 있지 않은 노드들이 같은 연결 리스트에 속하는지 어떻게 알 수 있을까?
    - 노드는 노드에 저장된 데이터 뿐만 아니라 연결리스트 내에 다음 노드의 메모리 주소도 저장하기 때문에 위의 의문이 해결된다.

~~~java
class Node{
        int data;
        Node next_node = null;
}
~~~
- 노드 클래스에는 속성이 두 가지 있다.
- 노드에 저장해야하는 값인 data와 리스트 내 다음 노드의 링크인 next_node이다.

✔️ [연결리스트 구현 코드](https://github.com/SeokHyeMin/TIL/blob/main/자료구조와%20알고리즘/Code/LinkedListNode.java)
- 연결 리스트의 읽기와 검색의 효율성은 O(N)이다.
- 하지만 연결 리스트의 삽입 효율성은 O(1)이다.  
    - 그 전의 노드가 새로 삽입할 노드의 링크를 가리키게 해주면 되기 때문.
    - 배열처럼 나머지 값들을 이동할 일이 없다.
- 삭제도 삽입과 마찬가지로 효율성은 O(1)이다.
- 배열과 큰 차이가 없어보이지만 연결리스트가 빛을 발하는 경우는 한 리스트를 검사해서 많은 원소를 삭제하는 경우이다.

### 이중 연결리스트
- 각 노드에 2개의 링크가 있다는 점을 제외하면 연결 리스트와 비슷하다.
- 한 링크는 다음 노드를 가리키고, 다른 한 링크는 **앞 노드**를 가리킨다.
- 큐를 이중 연결리스트를 이용해서 구현하면 삽입과 삭제를 모두 O(1)에 할 수 있다.

### LinkedList 관련 알고리즘 문제
- 정렬되지 않은 LinkedList에서 중복값 삭제
    - 버퍼사용 O
        - 공간복잡도 O(n), 시간복잡도 O(n)
    - [버퍼사용 X](https://github.com/SeokHyeMin/TIL/blob/main/자료구조와%20알고리즘/Code/LinkedListNode.java#L47)
        - 공간복잡도 O(1), 시간복잡도 O(n<sup>2</sup>)

- 단방향 LinkedList의 끝에서 k번째 노드를 찾는 알고리즘
    - 방법1 : 연결리스트를 처음부터 끝까지 가면서 길이를 알아낸 후, 길이에서 찾고자 하는 인덱스의 값을 빼주고 1을 더해 원하는 값을 찾는 방법.
        - 1을 더하는 이유는 k가 1일때 맨 뒤의 노드를 꺼내도록 코드를 구현할 것이기 때문에 이를 생각하여 1을 더해주어야한다.
    - 방법2 : 재귀호출을 사용하여 해결
    


<br><br>
참조 : 누구나 자료구조와 알고리즘
