## 재귀
- **재귀**는 함수가 자기 자신을 호출할 때를 말하는 공식 명칭이다.
#### ✔ **기저조건** : 재귀에 쓰이는 용어로 메서드가 반복되지 않는 경우를 **기저 조건이라고 한다.**
~~~java
public void countdown(number){
    System.out.println(number);
    if(number==0){ //기저조건
        return;
    }else{
        countdown(number-1);
    }
}

public void factorial(number){
    
    if (number == 1){ //기저 조건
        return 1;
    }else{
        return number * factorial(number-1);
    }
}
~~~

#### **재귀 코드 읽는 방법**
1. 기저 조건이 무엇인지 찾는다.
2. 기저 조건을 다룬다는 가정하에 함수를 살펴본다.
3. 기저 조건 바로 전 조건을 다룬다는 가정하에 함수를 살펴본다.
4. 한 번에 한 조건씩 올라가면서 계속 분석한다.

- 컴퓨터는 스택을 사용해 어떤 함수를 호출 중인지 기록한다. 
- 이러한 스택을 목적에 맞게 **호출 스택**이라고 한다.
~~~
- factorial(3)의 경우 컴퓨터는 factorial(3)을 호출하며 시작한다.
- 하지만 이 메서드가 종료되기 전에 factorial(2)를 호출한다. 이 때 컴퓨터는 아직 factorial(3)을 실행 중인지 알려면 
이러한 정보를 호출 스택에 푸시 해야한다.
- 마찬가지로 factorial(2)를 실행하면 연이어 factorial(1)을 호출하게 된다.
- 컴퓨터는 factorial(2)를 실행 중임을 기억해야하므로 또한 호출 스택이 푸시한다.
- factorial(1)을 실행하면 1이 기저조건이므로 factorial(1)은 factorial메서드를 호출하지 않고 끝난다.
- 다음 작업은 호출 스택 맨 위에 있는 factorial(2)를 팝하여 실행 후 factorial(3)도 팝하여 완료한다.
- factorial(2)는 factorial(1)의 결과를 토대로 완료, factorial(3)은 factorial(2)의 결과를 토대로 완료된다.
~~~
📌 무한 재귀가 있을 경우 프로그램은 컴퓨터 메모리에 더 이상 공간이 없을 때까지 계속해서 같은 메서드를 호출 스택에 푸시하기 때문에 **스택 오버플로**라는 오류가 발생한다.
- 알고리즘 자체만으로는 얼마나 많은 단계를 깊이 들어가야 하는지 알 수 없을 때 재귀는 좋은 방법이 될 수 있다.



<br><br>
참조 : 누구나 자료구조와 알고리즘