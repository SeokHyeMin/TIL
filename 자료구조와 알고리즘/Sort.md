## 알고리즘
- 알고리즘이란 단순히 문제를 해결하는 절차.
- 컴퓨팅 관점에서 알고리즘은 특정 연산을 풀어나가는 절차를 뜻한다.


### 📌 Bubble Sort
- 버블정렬 순서
1. 배열 내에서 연속된 두 항목을 가리킨다. 첫 번째 항목과 두 번째 항목을 비교한다.
2. 두 항목의 순서가 뒤바뀌어 있으면(왼쪽 값이 오른쪽 값보다 크면) 두 항목을 교환한다.
3. "포인터"를 오른쪽으로 옮긴다.
4. 더 이상 교환하지 않을 때까지 1단계에서 3단계를 반복한다. (이 과정을 패스스루라고 부른다.)

✔️ [버블정렬 구현 코드](https://github.com/SeokHyeMin/TIL/blob/main/자료구조와%20알고리즘/Code/BubbleSort.java)
- 버블정렬이라고 부르는 이유는 각 패스스루 마다 정렬되지 않은 값 중 가장 큰 값, "버블"이 올바른 위치로 가게된다. (매 정렬 때 마다 가장 큰 값이 올바른 위치로 가게된다.)
- 버블 정렬 알고리즘에 포함된 단계는 총 두 단계이다.
    - **비교** : 어느 쪽이 더 큰지 두 수를 비교한다.
        - 배열의 원소가 5개인 경우 첫 번째 패스스루에서는 4번의 비교를, 두 번째는 3번의 비교를.. 결국 총 4+3+2+1 = 10번의 비교를 하게 된다.
    - **교환(swap)** : 정렬하기 위해 두 수를 교환한다.
        - 교환 또한, 배열이 내림차순으로 정렬되어 있는 최악의 시나리오 일 경우에는 교환도 각각 4,3,2,1번씩 총 10번의 교환이 일어난다.
 ~~~
- 만약 원소수가 20개인 배열이라면? 비교와 교환이 각각 190번씩 총 380단계이다.
- 원소수가 증가할 수록 단계 수가 기하급수적으로 늘어나는 것을 알 수 있다.
~~~
- 버블정렬은 N이 증가할 때 마다 대략 <span>**N<sup>2</sup>**</span>만큼 늘어남을 알 수 있다.
- 따라서 빅 오 표기법에서는 <span>**버블 정렬의 효율성을 O(N<sup>2</sup>)**</span>이라 부른다.
- O(N<sup>2</sup>)은 데이터가 증가할 때 단계수가 급격히 늘어나므로 비교적 비효율적인 알고리즘으로 간주된다.
- 참고로 O(N<sup>2</sup>)을 이차시간이라고도 부른다.

<hr>

### 📌 Selection Sort
- 선택정렬 순서
1. 인덱스 0에 있는 값을 확인하며 시작, 이 값이 현재 배열의 최솟값이다(지금까지 본 유일한 값이기 때문이다.) 이 인덱스를 변수에 저장한다.
2. 현재 변수에 들어있는 값보다 작은 값이 들어 있는 셀을 만나면 **변수가 새 인덱스를 가리키도록 값을 대체**한다.
3. 한 패스스루가 끝난 후, 현재 최솟값이 어느 인덱스에 들어 있는지 알게 되었으므로 그 인덱스의 값과 패스스루를 처음 시작했을 때의 값을 교환한다.(패스스루를 시작했을 때 인덱스는 0이고 두번째 패스스루에서는 인덱스 1일 것이다.)
4. 데이터가 모두 정렬될 때까지 반복한다.   

✔️ [선택정렬 구현 코드](https://github.com/SeokHyeMin/TIL/blob/main/자료구조와%20알고리즘/Code/SelectionSort.java)

- 선택 정렬은 비교와 교환, 두 종류의 단계를 포함한다.
- 즉, 각 패스스루 내에서 각 원소를 현재까지 찾은 최솟값과 비교하고, 최솟값을 올바른 위치에 있는 수와 교환한다.
- 5개의 원소를 포함하는 배열의 경우 총 10번의 비교와 최대 각각 1번의 교환 총 4번의 교환이 일어나게된다.

|N개의 원소 |버블 정렬에서 최대 단계 수|선택 정렬에서 최대 단계 수|
|----------|-------------------------|-----------------------|
|5|20|14(10번의 비교 + 4번의 교환)|
|10|90|54(45번의 비교 + 9번의 교환)|
|20|380|199(180번의 비교 + 19번의 교환)|
|40|1560|819(780번의 비교 + 39번의 교환)|
|80|6320|3239(3160번의 비교 + 79번의 교환)|
~~~
- 표에서 비교한 바와 같이 선택정렬이 버블정렬보다 단 계수가 두 배정도 더 적다.
- 선택정렬이 버블정렬보다 두 배 더 빠르다.
~~~
- **하지만 빅 오 표기법은 상수를 무시한다.** (지수가 아닌 수는 포함하지 않는다.)
- 선택정렬의 효율성 또한 <span>**O(N<sup>2</sup>)**</span>이다.
- 빅 오는 데이터가 많을 때 한 알고리즘이 어떤 시점부터 다른 알고리즘보다 더 빠름을 보장하므로 빅 오에서 서로 다른 분류에 속하는 두 알고리즘이라면 어떤 알고리즘을 써야 할지 대체로 알 수 있으며, 따라서 빅 오는 매우 유용한 도구 이지만 **같은 분류에 속하는 두 알고리즘이라면 어떤 알고리즘이 더 빠를지 알기 위해 더 분석해야한다.**
<hr>

### 📌 Insertion Sort
- 삽입정렬 순서
1. 첫 번째 패스스루에서 임시로 인덱스 1(두 번째 셀)의 값을 임시 변수에 저장한다.
2. 다음으로 왼쪽에 있는 각 값을 가져와 임시 변수에 있는 값과 비교하는 시프트 단계를 시작한다. 왼쪽에 있는 값이 임시 변수에 있는 값보다 크면 그 값을 오른쪽으로 시프트 한다.
**임시 변수에 있는 값보다 작은 값을 만나거나 배열의 왼쪽 끝에 도달해야 시프트 단계가 끝난다.**
3. 임시변수의 값을 현재 공백에 삽입한다.
4. 배열이 완전히 정렬될 때 까지 반복한다.

✔️ [삽입정렬 구현 코드](https://github.com/SeokHyeMin/TIL/blob/main/자료구조와%20알고리즘/Code/InsertionSort.java)

- 최악의 경우에 삽입 정렬은 대략 N<sup>2</sup>/2의 비교와 N<sup>2</sup>/2의 시프트가 일어난다.
- 임시 변수에 값을 저장하는 과정을 배열에서 그 값을 삭제하는 과정이라고 하면, 삭제는 N-1번, 값을 삽입하는 과정 또한, N-1번이다.
- 이렇게 삽입 정렬에 포함된 단계는 삭제, 비교, 시프트, 삽입 네 단계로 이루어져 있으며, 총합은 N<sup>2</sup> + 2N - 2지만, 빅 오는 상수를 무시하며, 빅 오 표기법은 가장 높은 차수 N만 비교한다. 
- 결론 : **삽입 정렬의 빅 오는 O(N<sup>2</sup>)이다.**

~~~
    버블정렬과 선택정렬, 삽입정렬의 빅 오는 동일하지만 버블 정렬과 삽입정렬보다 선택정렬이 두 배 정도 빠르다. 
    하지만 그렇다고 선택정렬이 가장 나은 방법일까?
~~~
- 최악의 경우로 봤을 때는 그렇게 보일 수 있지만 평균적인 시나리오라고 가정한다면 다르다.
- 선택정렬은 최악부터, 평균, 최선의 시나리오에 이르기까지 모두 N<sup>2</sup>/2단계가 걸린다.(미리 패스스루를 끝낼 메커니즘이 전혀 없기 때문)
- 하지만, 삽입 정렬이 최악의 경우에 N<sup>2</sup>단계가 걸린다면, 평균시나리오에서는 N<sup>2</sup>/2 단계, 최선의 시나리오에서는 약 N단계가 걸린다.
- 즉, 경우에 따라 더 나은 정렬이 달라진다.
- 최선의, 평균, 최악의 시나리오를 구분하는 능력은 기존 알고리즘을 최적화해서 훨씬 빠르게 만드는 것 만큼이나 사용자 요구에 맞는 최적의 알고리즘을 고르는 핵심 기술이다.
#### **최악의 경우를 대비하는 것도 좋지만 대부분은 평균적인 경우가 일어난다는 점을 명심하자**

<hr>

### 📌 QuickSort
-퀵 정렬은 분할이라는 개념에 기반한다.

#### **분할**
1. 왼쪽 포인터를 한 셀씩 계속 오른쪽으로 옮기면서 피벗보다 크거나 같은 값에 도달하면 멈춘다.
2. 이어서 오른쪽 포인터를 한 셀씩 계속 왼쪽으로 옮기면서 피벗보다 작거나 같은 값에 도달하면 멈춘다.
3. 왼쪽 포인터와 오른쪽 포인터가 가리키고 있는 값을 교환한다.
4. 두 포인터가 가리키는 값이 같거나 왼쪽 포인터가 오른쪽 포인터 바로 오른쪽으로 이동할 때까지 위 과정을 반복한다.

#### **퀵 정렬 알고리즘 동작 과정**
1. 배열을 분할한다. 분할 과정이 끝나면 피벗은 [올바른 위치](https://github.com/SeokHyeMin/TIL/blob/main/자료구조와%20알고리즘/Code/QuickSort.java#L29)에 오게 된다.
2. 피벗의 왼쪽과 오른쪽에 있는 하위 배열을 각각 또 다른 배열로 보고 1단계와 2단계를 재귀적으로 반복한다. 즉, 각 하위 배열을 분할하고 각 하위 배열에 있는 피벗의 왼쪽과 오른쪽에서 더 작아진 하위 배열을 얻는다. 이어서 이러한 하위 배열을 다시 분할하는 과정을 반복한다.
3. 하위 배열이 원소를 0개 또는 1개 포함하면 기저조건이므로 아무것도 하지 않는다.

✔️ [퀵정렬 구현 코드](https://github.com/SeokHyeMin/TIL/blob/main/자료구조와%20알고리즘/Code/QuickSort.java)

#### **퀵 정렬의 효율성**
- 분할에 필요한 단계는 두 종류이다.
    - 비교 : 각 값과 피벗을 비교한다.
        - 비교는 각 분할마다 배열 내 각 원소를 피벗과 비교하므로 최소 N번 비교한다.
    - 교환 : 적절한 때에 왼쪽과 오른쪽 포인터가 가리키고 있는 값을 교환한다.
        - 교환은 각 분할 마다 최소 한 번 교환하며, 한 분할에서 최대 N/2번 교환한다.
        - 대략 평균적으로 N/4번 정도 교환한다.
    - **즉, 분할은 총 대략 1.25N 단계가 걸리지만 빅 오 표기법은 상수를 무시하므로 O(N)시간에 분할을 할애한다.**
- 배열을 같은 크기의 하위 배열로 logN번 나눌 수 있고, 나눌 때 마다 원래 배열의 N개 셀 전부를 분할 해야하므로 하위 배열에서 일어나는 분할까지 보면 결국 퀵 정렬의 **평균적**인 단계는 약 N*log N 단계이다.
- **퀵 정렬의 평균적인 빅 오는 O(NlogN)이다.**

#### ✔️ 하지만 퀵 정렬의 최악의 시나리오에서는?
- 최악의 시나리오에서 퀵 정렬의 효율성은 O(N<sup>2</sup>)이다
- 결국 평균적인 시나리오에서는 퀵 정렬의 효율성은 O(NlogN)이지만 최악의 시나리오에서는 O(N<sup>2</sup>)이다.
- 하지만 그래도 앞선 정렬들 보다는 매우 빠르다는 것을 알 수 있다.

#### ✔️ 참고 : 퀵 셀렉트
- 퀵 셀렉트는 퀵 정렬처럼 분할에 기반하며, 퀵 정렬과 이진 검색의 하이브리드 정도로 생각할 수 있다.
- 퀵 셀렉트의 장점 중 하나는 **전체 배열을 정렬하지 않고도** 올바른 값을 찾을 수 있다는 것이다.
- 예를 들어 배열 내에서 두 번째로 작은 값을 찾고 싶은 경우
1. 처음에 퀵 정렬처럼 분할을 하여 첫 번째 피벗을 올바른 위치에 둔다.
2. 첫 번째 피벗이 다섯 번째 셀인 경우 오른쪽 배열은 모두 버리고 왼쪽 하위 배열에만 집중하여 다시 진행한다.
3. 왼쪽 하위 배열의 새 피벗이 정렬되고 난 후 세번째 셀이였다고 하면 이제 세 번째로 작은 값을 알게 되었다. 이어서 또 왼쪽 하위 배열로만 진행한다.
4. 이렇게 또 새로운 분할이 끝나면 가장 작은 값과 두 번째로 작은 값이 배열 내에서 올바른 위치에 있게 된다.
- **퀵 정렬은 배열을 반으로 나눌 때 마다 원래 배열의 모든 셀을 다시 분할해야 했지만, 퀵 셀렉트는 배열을 반으로 나눌 때 마다 필요한 반쪽, 즉 찾고 있는 값이 있을 반쪽만 분할하면 된다.**
- 퀵 셀렉트는 항상 2N단계가 걸린다. **퀵 셀렉트의 효율성 즉 빅 오는 O(N)이 된다.**

<hr>

### 📌 Merge Sort
- 함수가 호출될 때 마다 절반씩 잘라서 재귀적으로 함수를 호출하고, 맨 끝의 제일 작은 조각부터 두 개씩 병합해서 정렬된 배열을 merge해 나가는 방법이다.
- merge Sort는 실행시에 별도의 저장공간을 필요로 한다.
- N개씩 logN만큼 돌기 때문에 **빅 오는 O(NlogN)이다.**

✔️ [병합 정렬 구현 코드](https://github.com/SeokHyeMin/TIL/blob/main/자료구조와%20알고리즘/Code/MergeSort.java)






<br><br>
-참조 : 누구나 자료구조와 알고리즘
