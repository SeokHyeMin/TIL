## 알고리즘
- 알고리즘이란 단순히 문제를 해결하는 절차.
- 컴퓨팅 관점에서 알고리즘은 특정 연산을 풀어나가는 절차를 뜻한다.


### 📌 Bubble Sort
- 버블정렬 순서
1. 배열 내에서 연속된 두 항목을 가리킨다. 첫 번째 항목과 두 번째 항목을 비교한다.
2. 두 항목의 순서가 뒤바뀌어 있으면(왼쪽 값이 오른쪽 값보다 크면) 두 항목을 교환한다.
3. "포인터"를 오른쪽으로 옮긴다.
4. 더 이상 교환하지 않을 때까지 1단계에서 3단계를 반복한다. (이 과정을 패스스루라고 부른다.)

✔️ [버블정렬 구현 코드](https://github.com/SeokHyeMin/TIL/blob/main/자료구조와%20알고리즘/Code/BubbleSort.java)
- 버블정렬이라고 부르는 이유는 각 패스스루 마다 정렬되지 않은 값 중 가장 큰 값, "버블"이 올바른 위치로 가게된다. (매 정렬 때 마다 가장 큰 값이 올바른 위치로 가게된다.)
- 버블 정렬 알고리즘에 포함된 단계는 총 두 단계이다.
    - **비교** : 어느 쪽이 더 큰지 두 수를 비교한다.
        - 배열의 원소가 5개인 경우 첫 번째 패스스루에서는 4번의 비교를, 두 번째는 3번의 비교를.. 결국 총 4+3+2+1 = 10번의 비교를 하게 된다.
    - **교환(swap)** : 정렬하기 위해 두 수를 교환한다.
        - 교환 또한, 배열이 내림차순으로 정렬되어 있는 최악의 시나리오 일 경우에는 교환도 각각 4,3,2,1번씩 총 10번의 교환이 일어난다.
 ~~~
- 만약 원소수가 20개인 배열이라면? 비교와 교환이 각각 190번씩 총 380단계이다.
- 원소수가 증가할 수록 단계 수가 기하급수적으로 늘어나는 것을 알 수 있다.
~~~
- 버블정렬은 N이 증가할 때 마다 대략 N<sup>2</sup>만큼 늘어남을 알 수 있다.
- 따라서 빅 오 표기법에서는 버블 정렬의 효율성을 O(N<sup>2</sup>)이라 부른다.
- O(N<sup>2</sup>)은 데이터가 증가할 때 단계수가 급격히 늘어나므로 비교적 비효율적인 알고리즘으로 간주된다.
- 참고로 O(N<sup>2</sup>)을 이차시간이라고도 부른다.

<hr><br>

### 📌 Selection Sort
- 선택정렬 순서
1. 인덱스 0에 있는 값을 확인하며 시작, 이 값이 현재 배열의 최솟값이다(지금까지 본 유일한 값이기 때문이다.) 이 인덱스를 변수에 저장한다.
2. 현재 변수에 들어있는 값보다 작은 값이 들어 있는 셀을 만나면 **변수가 새 인덱스를 가리키도록 값을 대체**한다.
3. 한 패스스루가 끝난 후, 현재 최솟값이 어느 인덱스에 들어 있는지 알게 되었으므로 그 인덱스의 값과 패스스루를 처음 시작했을 때의 값을 교환한다.(패스스루를 시작했을 때 인덱스는 0이고 두번째 패스스루에서는 인덱스 1일 것이다.)
4. 데이터가 모두 정렬될 때까지 반복한다.   

✔️ [선택정렬 구현 코드](https://github.com/SeokHyeMin/TIL/blob/main/자료구조와%20알고리즘/Code/SelectionSort.java)

- 선택 정렬은 비교와 교환, 두 종류의 단계를 포함한다.
- 즉, 각 패스스루 내에서 각 원소를 현재까지 찾은 최솟값과 비교하고, 최솟값을 올바른 위치에 있는 수와 교환한다.
- 5개의 원소를 포함하는 배열의 경우 총 10번의 비교와 최대 각각 1번의 교환 총 4번의 교환이 일어나게된다.

|N개의 원소 |버블 정렬에서 최대 단계 수|선택 정렬에서 최대 단계 수|
|----------|-------------------------|-----------------------|
|5|20|14(10번의 비교 + 4번의 교환)|
|10|90|54(45번의 비교 + 9번의 교환)|
|20|380|199(180번의 비교 + 19번의 교환)|
|40|1560|819(780번의 비교 + 39번의 교환|
|80|6320|3239(3160번의 비교 + 79번의 교환|
~~~
- 표에서 비교한 바와 같이 선택정렬이 버블정렬보다 단 계수가 두 배정도 더 적다.
- 선택정렬이 버블정렬보다 두 배 더 빠르다.
~~~
- <span style="color:red">**하지만 빅 오 표기법은 상수를 무시한다.**</span> (지수가 아닌 수는 포함하지 않는다.)
- 선택정렬의 효율성 또한 <span style="color:red">**O(N<sup>2</sup>)**</span>이다.
- 빅 오는 데이터가 많을 때 한 알고리즘이 어떤 시점부터 다른 알고리즘보다 더 빠름을 보장하므로 빅 오에서 서로 다른 분류에 속하는 두 알고리즘이라면 어떤 알고리즘을 써야 할지 대체로 알 수 있으며, 따라서 빅 오는 매우 유용한 도구 이지만 **같은 분류에 속하는 두 알고리즘이라면 어떤 알고리즘이 더 빠를지 알기 위해 더 분석해야한다.**





<br><br>
-참조 : 누구나 자료구조와 알고리즘
