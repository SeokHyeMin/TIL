## 알고리즘
- 알고리즘이란 단순히 문제를 해결하는 절차.
- 컴퓨팅 관점에서 알고리즘은 특정 연산을 풀어나가는 절차를 뜻한다.


### 📌 Bubble Sort
- 버블정렬 순서
1. 배열 내에서 연속된 두 항목을 가리킨다. 첫 번째 항목과 두 번째 항목을 비교한다.
2. 두 항목의 순서가 뒤바뀌어 있으면(왼쪽 값이 오른쪽 값보다 크면) 두 항목을 교환한다.
3. "포인터"를 오른쪽으로 옮긴다.
4. 더 이상 교환하지 않을 때까지 1단계에서 3단계를 반복한다. (이 과정을 패스스루라고 부른다.)

✔️ [버블정렬 구현 코드](https://github.com/SeokHyeMin/TIL/blob/main/자료구조와%20알고리즘/Code/BubbleSort.java)
- 버블정렬이라고 부르는 이유는 각 패스스루 마다 정렬되지 않은 값 중 가장 큰 값, "버블"이 올바른 위치로 가게된다. (매 정렬 때 마다 가장 큰 값이 올바른 위치로 가게된다.)
- 버블 정렬 알고리즘에 포함된 단계는 총 두 단계이다.
    - **비교** : 어느 쪽이 더 큰지 두 수를 비교한다.
        - 배열의 원소가 5개인 경우 첫 번째 패스스루에서는 4번의 비교를, 두 번째는 3번의 비교를.. 결국 총 4+3+2+1 = 10번의 비교를 하게 된다.
    - **교환(swap)** : 정렬하기 위해 두 수를 교환한다.
        - 교환 또한, 배열이 내림차순으로 정렬되어 있는 최악의 시나리오 일 경우에는 교환도 각각 4,3,2,1번씩 총 10번의 교환이 일어난다.
 ~~~
- 만약 원소수가 20개인 배열이라면? 비교와 교환이 각각 190번씩 총 380단계이다.
- 원소수가 증가할 수록 단계 수가 기하급수적으로 늘어나는 것을 알 수 있다.
~~~
- 버블정렬은 N이 증가할 때 마다 대략 <span>**N<sup>2</sup>**</span>만큼 늘어남을 알 수 있다.
- 따라서 빅 오 표기법에서는 <span>**버블 정렬의 효율성을 O(N<sup>2</sup>)**</span>이라 부른다.
- O(N<sup>2</sup>)은 데이터가 증가할 때 단계수가 급격히 늘어나므로 비교적 비효율적인 알고리즘으로 간주된다.
- 참고로 O(N<sup>2</sup>)을 이차시간이라고도 부른다.

<hr>

### 📌 Selection Sort
- 선택정렬 순서
1. 인덱스 0에 있는 값을 확인하며 시작, 이 값이 현재 배열의 최솟값이다(지금까지 본 유일한 값이기 때문이다.) 이 인덱스를 변수에 저장한다.
2. 현재 변수에 들어있는 값보다 작은 값이 들어 있는 셀을 만나면 **변수가 새 인덱스를 가리키도록 값을 대체**한다.
3. 한 패스스루가 끝난 후, 현재 최솟값이 어느 인덱스에 들어 있는지 알게 되었으므로 그 인덱스의 값과 패스스루를 처음 시작했을 때의 값을 교환한다.(패스스루를 시작했을 때 인덱스는 0이고 두번째 패스스루에서는 인덱스 1일 것이다.)
4. 데이터가 모두 정렬될 때까지 반복한다.   

✔️ [선택정렬 구현 코드](https://github.com/SeokHyeMin/TIL/blob/main/자료구조와%20알고리즘/Code/SelectionSort.java)

- 선택 정렬은 비교와 교환, 두 종류의 단계를 포함한다.
- 즉, 각 패스스루 내에서 각 원소를 현재까지 찾은 최솟값과 비교하고, 최솟값을 올바른 위치에 있는 수와 교환한다.
- 5개의 원소를 포함하는 배열의 경우 총 10번의 비교와 최대 각각 1번의 교환 총 4번의 교환이 일어나게된다.

|N개의 원소 |버블 정렬에서 최대 단계 수|선택 정렬에서 최대 단계 수|
|----------|-------------------------|-----------------------|
|5|20|14(10번의 비교 + 4번의 교환)|
|10|90|54(45번의 비교 + 9번의 교환)|
|20|380|199(180번의 비교 + 19번의 교환)|
|40|1560|819(780번의 비교 + 39번의 교환)|
|80|6320|3239(3160번의 비교 + 79번의 교환)|
~~~
- 표에서 비교한 바와 같이 선택정렬이 버블정렬보다 단 계수가 두 배정도 더 적다.
- 선택정렬이 버블정렬보다 두 배 더 빠르다.
~~~
- **하지만 빅 오 표기법은 상수를 무시한다.** (지수가 아닌 수는 포함하지 않는다.)
- 선택정렬의 효율성 또한 <span>**O(N<sup>2</sup>)**</span>이다.
- 빅 오는 데이터가 많을 때 한 알고리즘이 어떤 시점부터 다른 알고리즘보다 더 빠름을 보장하므로 빅 오에서 서로 다른 분류에 속하는 두 알고리즘이라면 어떤 알고리즘을 써야 할지 대체로 알 수 있으며, 따라서 빅 오는 매우 유용한 도구 이지만 **같은 분류에 속하는 두 알고리즘이라면 어떤 알고리즘이 더 빠를지 알기 위해 더 분석해야한다.**
<hr>

### 📌 Insertion Sort
- 삽입정렬 순서
1. 첫 번째 패스스루에서 임시로 인덱스 1(두 번째 셀)의 값을 임시 변수에 저장한다.
2. 다음으로 왼쪽에 있는 각 값을 가져와 임시 변수에 있는 값과 비교하는 시프트 단계를 시작한다. 왼쪽에 있는 값이 임시 변수에 있는 값보다 크면 그 값을 오른쪽으로 시프트 한다.
**임시 변수에 있는 값보다 작은 값을 만나거나 배열의 왼쪽 끝에 도달해야 시프트 단계가 끝난다.**
3. 임시변수의 값을 현재 공백에 삽입한다.
4. 배열이 완전히 정렬될 때 까지 반복한다.

✔️ [삽입정렬 구현 코드](https://github.com/SeokHyeMin/TIL/blob/main/자료구조와%20알고리즘/Code/InsertionSort.java)

- 최악의 경우에 삽입 정렬은 대략 N<sup>2</sup>/2의 비교와 N<sup>2</sup>/2의 시프트가 일어난다.
- 임시 변수에 값을 저장하는 과정을 배열에서 그 값을 삭제하는 과정이라고 하면, 삭제는 N-1번, 값을 삽입하는 과정 또한, N-1번이다.
- 이렇게 삽입 정렬에 포함된 단계는 삭제, 비교, 시프트, 삽입 네 단계로 이루어져 있으며, 총합은 N<sup>2</sup> + 2N - 2지만, 빅 오는 상수를 무시하며, 빅 오 표기법은 가장 높은 차수 N만 비교한다. 
- 결론 : **삽입 정렬의 빅 오는 O(N<sup>2</sup>)이다.**

~~~
    버블정렬과 선택정렬, 삽입정렬의 빅 오는 동일하지만 버블 정렬과 삽입정렬보다 
    선택정렬이 두 배 정도 빠르다. 하지만 그렇다고 선택정렬이 가장 나은 방법일까?
~~~
- 최악의 경우로 봤을 때는 그렇게 보일 수 있지만 평균적인 시나리오라고 가정한다면 다르다.
- 선택정렬은 최악부터, 평균, 최선의 시나리오에 이르기까지 모두 N<sup>2</sup>/2단계가 걸린다.(미리 패스스루를 끝낼 메커니즘이 전혀 없기 때문)
- 하지만, 삽입 정렬이 최악의 경우에 N<sup>2</sup>단계가 걸린다면, 평균시나리오에서는 N<sup>2</sup>/2 단계, 최선의 시나리오에서는 약 N단계가 걸린다.
- 즉, 경우에 따라 더 나은 정렬이 달라진다.
- 최선의, 평균, 최악의 시나리오를 구분하는 능력은 기존 알고리즘을 최적하해서 훨씬 빠르게 만드는 것 만큼이나 사용자 요구에 맞는 최적의 알고리즘을 고르는 핵심 기술이다.
#### **최악의 경우를 대비하는 것도 좋지만 대부분은 평균적인 경우가 일어난다는 점을 명심하자**




<br><br>
-참조 : 누구나 자료구조와 알고리즘
