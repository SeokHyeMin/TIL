## 트리
- 트리는 노드기반 자료 구조 이지만 트리의 각 노드는 여러 노드로의 링크를 포함할 수 있다.

### 트리의 세 가지 용어
- 루트 : 가장 상위 노드를 루트라고 부른다.
- 노드의 하위 노드를 자식이라고 하고 상위 노드를 부모 노드라고 한다.
- 트리에는 레벨이 있다.

### Binary Tree(이진 트리)
- 각 노드의 자식은 0개,1개 또는 2개 이다.
- 한 노드에 자식이 둘이면 한 자식은 부모보다 작은 값을, 다른 자식은 부모보다 큰 값을 가져야한다.
    - 부모 노드의 두 자식 모두 부모보다 작은 값을 가지거나, 큰 값을 가지면 이진트리가 아니다.

#### Binary Search Tree
✔️ [구현 코드](https://github.com/SeokHyeMin/TIL/blob/main/자료구조와%20알고리즘/Code/BinarySearchTree.java)
- 트리 안의 데이터가 왼쪽 노드와 그 이하 자식 노드들은 현재 노드보다 모두 작아야하고, 오른쪽 노드와 그 이하 자식 노드들은 현재 노드보다 커야한다.
- 예를 들어 루트 기준 왼쪽 노드와 그 자식 노드들은 루트보다 작아야하고, 루트 기준 오른쪽 노드와 그 자식 노드들은 루트보다 커야만 Binary Search Tree이다.
- **검색**
    - 트리의 검색은 반드시 루트부터 시작한다.
    - 각 단계를 수행할 때 마다 값이 들어있을 남은 공간 중 반을 제거하기 때문에 이진 트리의 검색은 O(logN)이다.
- **삽입**
    - 삽입은 항상 검색에 한 단계가 더 추가된다.
    - 올바른 위치를 찾아서 삽입하는 단계가 하나 더 추가되는 것이기 때문이다.
    - 삽입은 logN + 1단계가 걸리므로 효율성은 O(logN)이다. (빅 오는 상수 무시)
- 정렬된 배열은 검색에 O(logN), 삽입에 O(N)이 걸리는 반면에 이진 트리는 검색과 삽입 둘 다 O(logN)이다.
- **삭제**
    - [삭제 코드](https://github.com/SeokHyeMin/TIL/blob/main/자료구조와%20알고리즘/Code/BinarySearchTree.java#L41)가 위의 두 경우보다 다소 복잡하다.
    - 삭제할 노드에 자식이 없으면 그냥 삭제한다.
    - 삭제할 노드에 자식이 하나면 노드를 삭제하고, 자식을 삭제된 노드가 있던 위치에 넣는다.
    - 자식이 둘인 노드를 삭제할 떄는 삭제된 노드를 후속자 노드로 대체한다.
        - 후속자 노드란? 삭제된 노드보다 큰 값 중 최솟값을 갖는 자식 노드이다.
        - 만약 후속자 노드에 오른쪽 자식이 있으면 후속자를 삭제된 노드가 있던 자리에 넣은 후, 후속자 노드의 오른쪽 자식을 후속자 노드의 원래 부모의 왼쪽 자식으로 넣는다.
    - 삭제에는 검색 한 번과 연결이 끊긴 자식을 처리하는 단계가 추가적으로 필요하기 때문에 삽입과 마찬가지로 O(logN)이다.

#### **Binary Tree의 3가지 구현방법**
✔️ [구현 코드](https://github.com/SeokHyeMin/TIL/blob/main/자료구조와%20알고리즘/Code/Tree.java)
- 자료구조에서 모든 노드를 방문하는 과정을 자료 구조 순회라 한다.
- 재귀는 순회를 수행하는 훌륭한 도구이다.
- 트리 순회는 트리의 모든 노드를 방문하므로 O(N)이 걸린다.
1. Inorder (Left, Root, Right) - [중위순회](https://github.com/SeokHyeMin/TIL/blob/main/자료구조와%20알고리즘/Code/Tree.java#L29)
2. Preorder (Root, Left, Right) - [전위순회](https://github.com/SeokHyeMin/TIL/blob/main/자료구조와%20알고리즘/Code/Tree.java#L38)
3. Postorder (Left, Right, Root) - [후위순회](https://github.com/SeokHyeMin/TIL/blob/main/자료구조와%20알고리즘/Code/Tree.java#L47)


#### **Tree 관련 알고리즘 문제**
- [정렬이 되어있고, 고유한 정수로만 이루어진 배열을 이진검색 트리로 만들기](https://github.com/SeokHyeMin/TIL/blob/main/자료구조와%20알고리즘/Code/ArrayToBinarySearchTree.java)
- [이진트리의 노드들을 각 레벨별로 LinkedList에 담는 알고리즘을 구현](https://github.com/SeokHyeMin/TIL/blob/main/자료구조와%20알고리즘/Code/BinaryTreeToLinkedList.java)하라.
(예를 들어, 5개의 깊이를 가지는 트리라면 5개의 LinkedList를 만들어야한다.)





## Heap
### 힙이란?
> 힙이란 최대값이나 최소값을 찾아내는 연산을 빠르게 하기 위해 고안된 **완전 이진트리를 기본**으로한 자료구조이다.

### 힙에는 최소 힙(Min Heap)과 최대 힙(Max Heap) 이렇게 두 가지 Heap이 있다.
#### **최소 힙(Min Heap)**
최소 힙은 작은 값을 항상 위의 노드에 있게 해서 트리의 루트에는 가장 작은 값이 오도록 하는 것이다.

#### **최대 힙(Max Heap)**
최대 힙은 가장 큰 값이 맨 위에 오도록 모든 노드들은 자기 부모 노드가 자기 값보다 큰 값을 가지는 트리이다.

- 근본적으로 두 힙의 원리는 같으므로 최소 힙만 알면 최대 힙은 숫자만 반대로 되어 있다고 생각하면 된다. 문자열을 하나씩 찾고, 또 다음 문자는 자식 노드에서 찾는다.


## Trie(트라이)
트라이는 특별히 문자열에서 검색을 빠르게 해주는 트리 구조이다.
- 한 글자에 레벨 하나씩 가도록 하여 문자열을 한 자씩, 다음 문자는 자식 노드에서 찾는 구조이다.
- 트리의 문자열이 세로로 저장되어 있는 것이다.
- 문자열이 죄다 똑같은 것으로 시작하는 것은 아니니 루트 노드는 비워주고, 그 다음부터 찾는다.

<br><br>
참조 : 누구나 자료구조와 알고리즘