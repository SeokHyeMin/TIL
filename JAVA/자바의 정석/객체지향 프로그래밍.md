## Class
- 클래스는 '객체를 생성하기 위한 틀'이며 '클래스는 속성과 기능으로 정의되어 있다.'

### 1. 클래스 - 데이터와 함수의 결합
프로그래밍언어에서 데이터 처리를 위한 데이터 저장형태 발전
1. 변수 : 하나의 데이터를 저장할 수 있는 공간
2. 배열 : 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
3. 구조체 : 서로 관련된 여러 데이터를 **종류에 관계없이** 하나의 집합으로 저장할 수 있는 공간
4. 클래스 : 데이터와 함수의 결합(구조체 + 함수)

#### **클래스는 서로 관련된 변수들을 정의하고 이들에 대한 작업을 수행하는 함수들을 함께 정의한 것이라고 볼 수 있다.**
- 그래서 C언어에서는 문자열을 문자 배열로 다루지만, JAVA에서는 String이라는 클래스로 문자열을 다룬다.
- 문자열을 단순히 문자의 배열로 정의하지 않고 클래스로 정의한 이유는 문자열과 문자열을 다루는데 필요한 함수들을 함께 묶기 위해서 이다.

### 2. 클래스 - 사용자정의 타입(user-defined type)
프로그래밍 언어에서 제공하는 **자료형(primitive type)**외에 프로그래머가 서로 관련된 변수들을 묶어서 하나의 타입으로 새로 추가하는 것을 사용자 정의 타입(user-defined type)이라고 한다.
- 자바와 같은 객체 지향언어에서는 클래스가 곧 사용자정의 타입이다. 
- 기본형의 개수는 8개로 정해져있지만 참조형의 개수가 정해져 있지 않은 이유는 프로그래머가 새로운 타입을 추가할 수 있기 때문이다.

<hr>

## 변수와 메서드
### 선언위치에 따른 변수의 종류
- 변수는 클래스 변수, 인스턴스 변수, 지역변수 모두 세 종류가 있다.
- 변수의 종류를 결정짓는 중요한 요소는 '변수의 선언된 위치'이다.
- 멤버변수를 제외한 나머지 변수들은 모두 지역변수이며, 멤버변수중 static이 붙은 것은 클래스 변수, 붙지 않은 것은 인스턴스 변수이다.

~~~java
    class Variables{
        int iv;     //인스턴스 변수
        static int cv;  //클래스 변수

        void method(){
            int lv = 0; //지역 변수
        }
    }
~~~

|변수의 종류 |선언위치|생성시기|
|---------|------------------|---------------------------|
|클래스 변수(class variable)|클래스 영역|클래스가 메모리에 올라갈 때|
|인스턴스 변수(instance variable)|클래스 영역|인스턴스가 생성되었을 때|
|지역변수(local variable)|클래스 영역 이외의 영역(메서드, 생성자, 초기화 블럭 내부)|변수 선언문이 수행되었을 때|

#### **1. 인스턴스 변수(instance variable)**
- 클래스 영역에 선언되며, 클래스의 인스턴스를 생성할 때 만들어 진다.
- 인스턴스 변수의 값을 읽어오거나 저장하기 위해서는 먼저 인스턴스를 생성해야 한다.
- **인스턴스는 독립적인 저장공간을 가지므로 서로 다른 값을 가질 수 있다.**

✔️인스턴스 마다 고유한 상태를 유지해야하는 경우, 인스턴스 변수로 사용한다.

#### **2. 클래스 변수(class variable)**
- 클래스 변수를 선언하는 방법은 인스턴스 변수 앞에 static만 붙이면 된다.
- 인스턴스마다 독립적인 저장공간을 갖는 인스턴스 변수와는 달리, **클래스 변수는 모든 인스턴스가 공통된 저장공간(변수)을 공유하게 된다.**
- 클래스 변수를 사용할 때는 '클래스이름.클래스변수'와 같은 형식으로 사용한다.
- 참조변수를 통해서도 사용할 수 있지만 인스턴스와 헷갈릴 수 있기 때문에 위의 형식을 추천.
✔️ 한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야하는 속성의 경우, 클래스 변수로 선언해야한다.

#### **3. 지역 변수(local variable)**
- 메서드 내에 선언되어 메서드 내에서만 사용가능하며, 메서드가 종료되면 소멸되어 사용할 수 없게 된다.

### **메서드**
'메서드(method)'는 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것이다.
- 메서드가 작업을 수행하는데 필요한 값만 넣고 원하는 결과를 얻으면 될 뿐, 이 메서드가 내부적으로 어떤 과정을 거쳐 결과를 만들어내는지 전혀 몰라도 된다.
- 그래서 메시지를 내부가 보이지 않는 '블랙박스(blackbox)'라고도 한다.

#### 메서드를 사용하는 이유
1. 높은 재사용성(reusability)
    - 한 번 만들어 놓은 메서드는 몇 번이고 호출할 수 있으며, 다른 프로그램에서도 사용이 가능하다.

2. 중복된 코드의 제거
    - 같은 내용의 문장들이 여러 곳에서 반복해서 나타마녀, 반복되는 문장들을 묶어서 하나의 메서드로 작성해 놓으면 반복되는 문장들 대신 메서드를 호출하는 한 문장으로 대체할 수 있다.
    - 변경사항이 발생했을 때 이 메서드만 수정하면 되므로 관리도 쉽고 오류의 발생가능성도 낮아진다.

3. 프로그램의 구조화
    - 큰 규모의 프로그램에서는 문장들을 작업단위로 나눠서 여러 개의 메서드에 담아 프로그램의 구조를 단순화 시키는 것이 필수적이다.
    - main메서드는 프로그램의 전체 흐름이 한눈에 들어올 정도로 단순하게 구조화하는 것이 좋다.
    - 그래야 나중에 프로그램에 문제가 발생해도 해당 부분을 쉽게 찾아서 해결할 수 있다.
    - 처음에 프로그램을 설계할 때 내용이 없는 메서드를 작업단위로 만들어 놓고, 하나씩 완성해나가는 것도 프로그램을 구조화하는 좋은 방법이다.


### **return문**

return문은 현재 실행중인 메서드를 종료하고 호출한 메서드로 되돌아 간다.

- 반환 타입이 void인 경우, return문 없이도 아무런 문제가 없는데, 그 이유는 컴파일러가 메서드의 마지막에 ‘return;’을 자동적으로 추가해주었기 때문이다.
- 반환 타입이 void가 아니라면, 항상 결과값이 반환되도록 해야한다.

### **JVM의 메모리 구조**

응용프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.

📌 **3가지 주요 영역**

1. **메서드 영역(method area)**
    
    -프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(*.class)을 읽어서 분석하여 클래스에 대한 정보(클래스 데이터)를 이곳에 저장한다. **이 때, 그 클래스의 클래스변수(class variable)도 이 영역에 함께 생성된다.**
    
2. **힙(heap)**
    
    -인스턴스가 생성되는 공간. 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다.
    
    **즉, 인스턴스변수(instance variable)들이 생성되는 공간이다.**
    
3. **호출스택(call stack 또는 execution statck)**
    
    -호출스택은 **메서드의 작업에 필요한 메모리 공간을 제공**한다.
    
    -**메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당되며, 이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용된다.**
    
    -그리고 메서드가 작업을 마치면 할당되었던 메모리공간은 반환되어 비워진다.
    
    -각 메서드를 위한 메모리상의 작업공간은 서로 구별되며, 첫 번째로 호출된 메서드를 위한 작업공간이 호출스택의 맨 밑에 마련되고, 첫 번째 메서드 수행 중에 다른 메서드를 호출하면, 첫 번째 메서드의 바로 위에 두 번째로 호출된 메서드를 위한 공간이 마련된다.
    
    -호출스택의 제일 위에 있는 메서드가 현재 실행 중인 메서드이다.
    
    -아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.
    

### **기본형 매개변수와 참조형 매개변수**

자바에서는 메서드를 호출할 때 매개변수로 지정한 값을 메서드의 매개변수에 복사해서 넘겨준다.

매개변수의 타입이 기본형(primitive type)일 때는 기본형 값이 복사되겠지만, 참조형(reference type)이면 인스턴스의 주소가 복사된다.

- 메서드의 매개변수를 기본형으로 선언하면 단순히 저장된 값만 얻지만, **참조형으로 선언하면 값이 저장된 곳의 주소를 알 수 있기 때문에 값을 읽어오는 것은 물론 값을 변경하는 것도 가능하다.**

✔️ 기본형 매개변수 : 변수의 값을 읽기만 할 수 있다.(read only)

✔️ 참조형 매개변수 : 변수의 값을 읽고 변경할 수 있다.(read & write)
       -그래서 배열의 정렬을 생각해보면 sort(int[] arr)라는 메서드에서 배열을 오름차순으로 정렬해놓으면 원래 배열에도 영향을 미치는 것이다.
       
📌 반환타입이 참조형이라는 것은 메서드가 ‘객체의 주소를 반환한다는 것을 의미한다.

### **재귀호출(recursive call)**

메서드의 내부에서 자신을 다시 호출하는 것을 ‘재귀호출(recursive call)’이라 하고, 재귀호출을 하는 메서드를 ‘재귀 메서드’라 한다.

- 반복문은 그저 같은 문장을 반복해서 수행하는 것이지만, 메서드를 호출하는 것은 반복문 보다 몇 가지 과정(매개변수 복사와 종료후 복귀할 주소 저장 등등)이 추가로 필요하기 때문에 반복문보다 재귀호출의 수행시간이 더 오래걸린다.
- 반복문 대신 재귀호출을 사용하는 이유는 재귀호출이 주는 논리적 간결함 때문이다.
- 어떤 작업을 반복적으로 처리해야한다면, 먼저 반복문으로 작성해보고 너무 복잡하면 재귀호출로 간단히 할 수 없는지 고민해볼 필요가 있다. (재귀호출은 비효율적이므로 재귀호출에 드는 비용보다 재귀호출의 간결함이 주는 이득이 충분히 큰 경우에 사용하자.)

```java
class PowerTest{
	public static void main(String[] args){
		int x = 2;
		int n = 5;
		long result = 0;
		
		for(int i=1; i<=n; i++){
			result += power(x, i);
		}
		System.out.println(result);
	}
	static long power(int x, int n){//2의 n승을 구하는 재귀함수
		if(n==1) return x;
		return x * power(x, n-1);  
	}

}
```

### **클래스 메서드(static method)와 인스턴스 메서드**

변수에서 그랬던 것과 같이, 메서드 앞에 static이 붙어 있으면 클래스 메서드이고 붙어 있지 않으면 인스턴스 메서드이다.

- 클래스 메서드도 클래스 변수처럼, 객체를 생성하지 않고도 ‘클래스이름.메서드이름(매개변수)’와 같은 식으로 호출이 가능하다.
- 반면에 인스턴스 메서드는 반드시 객체를 생성해야만 호출할 수 있다.

**그렇다면 클래스를 정의할 때, 어느 경우에 static을 사용해서 클래스 메서드로 정의해야하는 것일까?**

#### **인스턴스 메서드**

- 인스턴스 메서드는 인스턴스 변수와 관련된 작업을 하는, 즉 메서드의 작업을 수행하는데 인스턴스 변수를 필요로 하는 메서드이다.
- 그런데 인스턴스 변수는 인스턴스(객체)를 생성해야만 만들어지므로 인스턴스 메서드 역시 인스턴스를 생성해야만 호출할 수 있다.

#### **클래스 메서드(static method)**

- 반면에 메서드 중에서 **인스턴스와 관계없는(인스턴스 변수나 인스턴스 메서드를 사용하지 않는) 메서드를 클래스 메서드(static method)로 정의한다.**
- 인스턴스 변수를 사용하지 않는다고 해서 반드시 클래스 메서드로 정의해야하는 것은 아니지만 특별한 이유가 없는 한 그렇게 하는 것이 일반적이다.

1. 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다.
    
    -생성된 인스턴스들은 서로 독립적이기 때문에 각 인스턴스의 변수는 서로 다른 값을 유지한다.
    
    -하지만 모든 인스턴스에서 같은 값이 유지되어야 하는 변수가 있다면 static을 붙여서 클래스 변수로 정의해야한다.
    
2. 클래스 변수(static변수)는 인스턴스를 생성하지 않아도 사용할 수 있다.
    
    -static이 붙은 변수(클래스 변수)는 클래스가 메모리에 올라갈 때 이미 자동적으로 생성되기 때문에 인스턴스를 생성하지 않아도 사용할 수 있다.
    
3. 클래스 메서드(static메서드)
    
    -인스턴스 변수는 인스턴스가 반드시 존재해야만 사용할 수 있는데, 클래스 메서드는 인스턴스 생성없이 호출 가능하므로 클래스 메서드가 호출되었을 때 인스턴스가 존재하지 않을 수도 있다. 
    
    (**그렇기 때문에 클래스 메서드에서 인스턴스변수의 사용을 금지한다.)**
    
    -반면에 인스턴스변수나 인스턴스 메서드에서는 static이 붙은 멤버들을 사용하는 것이 언제나 가능하다.(인스턴스 변수가 존재한다는 것은 static변수가 이미 메모리에 존재한다는 것을 의미한다.)
    
4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려하자.
    
    -메서드의 작업내용 중에서 인스턴스변수를 필요로한다면 static을 붙일 수 없다.
    
    -반대로 인스턴스 변수를 필요로하지 않는다면 static을 붙이자.
    
    -메서드의 호출시간이 짧아지므로 성능이 향상된다.
    
    -**static을 안 붙인 메서드(인스턴스 메서드)는 실행 시 호출되어야할 메서드를 찾는 과정이 추가적으로 필요하기 때문에 시간이 더 걸린다.**
    

<aside>
💡 정리

-클래스의 멤버변수 중 모든 인스턴스에 공통된 값을 유지해야하는 것이 있는지 살펴보고 있다면, static을 붙여 클래스변수로 만들어 주자.

-작성한 메서드 중에서 인스턴스 변수나 인스턴스 메서드를 사용하지 않는 메서드에 static을 붙일 것을 고려하자.
</aside>


📌 **어떤 경우 인스턴스 메서드로, 또는 클래스 메서드로 선언해야하는지 그 차이를 잘 이해하도록 하자.**

### **클래스 멤버와 인스턴스 멤버간의 참조와 호출**

같은 클래스에 속한 멤버들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조 또는 호출이 가능하다.

단, 클래스 멤버가 인스턴스 멤버를 참조 또는 호출하고자 하는 경우에는 인스턴스를 생성해야한다.

**그 이유는 인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만!!!! 클래스 멤버가 존재하는 시점에는 인스턴스 멤버가 존재하지 않을 수 있기 때문이다.!!!**

### **오버로딩(overloading)**

#### **오버로딩이란?**
메서드도 변수와 마찬가지로 같은 클래스 내에서 서로 구별될 수 있어야 하기 때문에 각기 다른 이름을 가져야한다. **그러나 자바에서는 한 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메서드가 있더라도 매개변수의 개수 또는 타입이 다르면, 같은 이름을 사용해서 메서드를 정의할 수 있다.**

- 이처럼, 한 클래스 내에 같은 이름의 메서드를 여러 개 정의 하는 것을 ‘메서드 오버로딩(method overloading)’ 또는 간단히 ‘오버로딩(overloading)’이라 한다.

#### **오버로딩의 조건**

1. 메서드 이름이 같아야한다.
2. 매개변수의 개수 또는 타입이 달라야한다.

📌 **오버로딩된 메서드들은 매개변수에 의해서만 구별될 수 있으므로 반환타입은 오버로딩을 구현하는데 아무런 영향을 주지 못한다는 것에 주의하자.**

-오버로딩의 예시로 println메서드가 있다. 이 메서드를 호출 할 때 매개변수로 넘겨주는 타입에 따라서 오버로딩된 메서드들 중 하나가 선택되어 실행된다. (그래서 어떤 종류의 매개변수를 지정해도 출력할 수 있다.)

#### **오버로딩의 장점**

- 메서드의 이름만 보고도 ‘이 메서드들은 이름이 같으니, 같은 기능을 한다’라고 쉽게 예측이 가능하다.
- 메서드의 이름을 절약할 수 있다.
- 메서드의 이름을 기억하기도 쉽고, 짧게 할 수 있어서 오류의 가능성을 많이 줄일 수 있다.

### **가변인자(varargs)와 오버로딩**

기존에는 메서드의 매개변수가 고정적이었으나 JDK1.5부터 동적으로 지정해 줄 수 있게 되었으며, 이 기능을 ‘가변인자(variable arguments)’라고 한다.

- 가변인자는 **‘타입… 변수명’**과 같은 형식으로 선언하며, PrintStream클래스의 printf()가 대표적인 예이다.
- 가변인자 외에도 매개변수가 더 있다면, 가변인자를 매개변수 중에서 제일 마지막에 선언해야한다.

```java
public PrintStream printf(String format, Object... args){} //ok

//가변인자는 항상 마지막 매개변수이어야 하므로 컴파일 에러가 발생한다.
public PrintStream printf(Object... args, String format){} //컴파일에러 발생
```

여러 문자열을 하나로 결합하여 반환하는 concatenate메서드를 작성한다면, 매개변수의 개수를 다르게 해서 여러 개의 메서드를 작성해야하지만, 가변인자를 사용하면

```java
String concatenate(String... str){//생략}
```

이렇게 인자의 개수를 가변적으로 할 수 있으며, 인자가 아예 없어도 되고, 배열도 인자가 될 수 있다.

이러한 기능이 가능한 이유는?

- 가변인자는 내부적으로 배열을 이용한다.
- 그래서 가변인자가 선언된 메서드를 호출 할 때 마다 배열이 새로 생성된다.
- 그렇기 때문에 가변인자가 편리하긴 하지만, 비효율적인 부분도 있으므로 꼭 필요한 부분에만 가변인자를 사용하도록 하자.

📌 **주의!**

-가변인자를 선언한 메서드를 오버로딩하면, 메서드를 호출 했을 때 구별되지 않는 경우가 발생하기 때문에(매개변수로 차이를 두기 어렵다.) 주의해야하며 가능하면 가변인자를 사용한 메서드는 오버로딩하지 않는 것이 좋다.
<hr>

## 생성자(Constructor)

#### **생성자란?**

**생성자는 인스턴스가 생성될 때 호출되는 ‘인스턴스 초기화 메서드’이다.** 따라서 인스턴스 변수의 초기화 작업에 주로 사용되며, 인스턴스 생성 시에 실행되어야 할 작업을 위해서도 사용된다.

-생성자도 오버로딩이 가능하다.

#### 생성자의 조건

1. 생성자의 이름은 클래스의 이름과 같아야한다.
2. 생성자는 리턴값이 없다.

**연산자 new가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것이 아니다.**

- 생성자는 단순히 인스턴스변수들의 초기화에 사용되는 조금 특별한 메서드일 뿐이다.
- 생성자가 갖는 몇가지 특성을 제외하면 메서드와 다르지 않다.

```java
Card c = new Card();

1. 연산자 new에 의해서 메모리(heap)에 Card클래스의 인스턴스가 생성된다.
2. 생성자 Card()가 호출되어 수행된다.
3. 연산자 new의 결과로, 생성된 Card인스턴스의 주소가 반환되어 참조변수 c에 저장된다.
```

지금까지 인스턴스를 생성하기 위해 사용해왔던 ‘클래스이름()’이 바로 생성자이였던 것이다.

**인스턴스를 생성할 때는 반드시 클래스 내에 정의된 생성자 중의 하나를 선택하여 지정해주어야 한다.**

#### **기본 생성자(default constructor)**

컴파일 할 때, 소스파일(*.java)의 클래스에 생성자가 하나도 정의되지 않은 경우 컴파일러는 자동적으로 기본 생성자를 추가하며 컴파일한다.

- 컴파일러가 자동적으로 기본 생성자를 추가해주는 경우는 **‘클래스 내에 생성자가 하나도 없을 때’** 뿐이라는 것을 명심하자.

#### **매개변수가 있는 생성자**

생성자도 메서드처럼 매개변수를 선언하여 호출 시 값을 넘겨받아서 인스턴스의 초기화 작업에 사용할 수 있다.

- 매개변수가 있는 생성자를 사용한다면 인스턴스를 생성하는 동시에 원하는 값으로 초기화를 할 수 있게 된다.

#### **생성자에서 다른 생성자 호출하기 - this(), this**

같은 클래스 멤버들 간에 서로 호출할 수 있는 것처럼 생성자 간에도 서로 호출이 가능하다.

이를 위해 만족해야할 조건

1. 생성자의 이름으로 클래스이름 대신 this를 사용한다.
2. **한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.**

- 생성자의 매개변수로 선언된 변수의 이름과 인스턴스변수의 이름이 같은 경우에는 어떻게 해야할까?
    - 인스턴스 변수 앞에 this를 붙여서 사용하면 된다.
    - 그러면 this가 붙은 것은 인스턴스 변수로, 붙지 않은 것은 생성자의 매개변수로 구별되게 할 수 있다.
    - ‘this’는 참조변수로 인스턴스 자신을 가리킨다. **인스턴스의 주소가 저장되어 있다.**
    - 참조변수를 통해 인스턴스의 멤버에 접근할 수 있는 것 처럼, ‘this’로 인스턴스 변수에 접근 할 수 있는 것이다.
        - 참고로, ‘this’를 사용할 수 있는 것은 인스턴스멤버 뿐이다.
        - static메서드가 호출된 시점에 인스턴스가 존재하지 않을 수 있기 때문이다.
    - 생성자를 포함한 모든 인스턴스 메서드에는 자신이 관련된 인스턴스를 가리키는 참조변수 ‘this’가 지역변수로 숨겨진 채로 존재한다.
    
    <aside>
    💡 정리

    -this : 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있다.

    -this(), this(매개변수) : 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용한다.
    
    </aside>
    
<hr>

## 변수의 초기화

#### **변수의 초기화**

변수를 선언하고 처음으로 값을 저장하는 것을 ‘변수의 초기화’라고 한다.

- 멤버변수는 초기화를 하지 않아도 자동적으로 변수의 자료형에 맞는 기본 값으로 초기화가 이루어지므로 초기화하지 않고 사용해도 된다.(멤버변수 : 클래스변수, 인스턴스 변수)
- 하지만, **지역변수는 사용하기 전에 반드시 초기화 해야한다.**

#### **멤버변수의 초기화 방법**

1. 명시적 초기화(explicit initialization)
2. 생성자(constructor)
3. 초기화 블럭(initializtaion block)
    
    -인스턴스 초기화 블럭 : 인스턴스변수를 초기화 하는데 사용
    
    -클래스 초기화 블럭 : 클래스변수를 초기화 하는데 사용
    

#### **명시적 초기화(explicit initialization)**

변수를 선언과 동시에 초기화하는 것을 명시적 초기화라고 한다.

가장 기본적이면서도 간단한 초기화 방법이므로 여러 초기화 방법 중에서 가장 우선적으로 고려되어야 한다.

```java
class Car{
		int door = 4; //기본형(primitive type) 변수의 초기화
		Engine e  = new Engine();  //참조형(reference type) 변수의 초기화
}
```

명시적 초기화가 간단하지만, 보다 복잡한 초기화 작업이 필요할 때는 ‘초기화 블럭(initialization block)’ 또는 생성자를 사용해야 한다.

#### **초기화 블럭(initialization block)**

초기화 블럭에는 ‘클래스 초기화 블럭’과 ‘인스턴스 초기화 블럭’ 두 가지 종류가 있다.

- 인스턴스 초기화 블럭은 클래스 내에 블럭{}을 만들고 그 안에 코드를 작성하기만 하면 된다.
- 클래스 초기화 블럭은 클래스 변수의 복잡한 초기화에 사용되며 인스턴스 초기화 블럭앞에 단순히 **static**만 붙이면 된다.

```java
class Test{
	static{
		//클래스 초기화 블럭
	}
	{
		//인스턴스 초기화 블럭
	}
}
```

**클래스 초기화 블럭은 클래스가 메모리에 처음 로딩될 때 한번만 수행되며, 인스턴스 초기화 블럭은 생성자와 같이 인스턴스를 생성할 때 마다 수행된다.**

📌 생성자 보다 인스턴스 초기화 블럭이 먼저 수행된다.

- 보통 인스턴스 변수의 초기화는 주로 생성자를 사용하고, 인스턴스 초기화 블럭은 모든 생성자에서 공통으로 수행돼야하는 코드를 넣는데 사용된다.
- 즉, 각 생성자마다 적어주어야하는 중복된 코드가 있다면 이 문장들을 각 생성자마다 써주기 보다는 인스턴스 블럭에 넣어주면 코드가 간결해진다.
    - 이처럼 코드의 중복을 제거하는 것은 코드의 신뢰성을 높여주고, 오류의 발생가능성을 줄여준다.
    - 바로 재사용정을 높이고 중복을 제거하는 것이 바로 객체지향프로그래밍이 추구하는 궁극적인 목표이다.

### 멤버변수의 초기화 시기와 순서

- **클래스 변수의 초기화 시점**
    - 클래스가 처음 로딩될 때 단 한 번 초기화 된다.
- **인스턴스 변수의 초기화 시점**
    - 인스턴스가 생성될 때 마다 각 인스턴스별로 초기화가 이루어진다.
- **클래스 변수의 초기화순서**
    - 기본값 → 명시적 초기화 → 클래스 초기화 블럭
- **인스턴스 변수의 초기화 순서**
    - 기본값 → 명시적 초기화 → 인스턴스 초기화 블럭 → 생성자

<br><br>
참조 : 자바의 정석 3rd Edition