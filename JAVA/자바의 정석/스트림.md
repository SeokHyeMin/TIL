# 스트림(Stream)
## 스트림이란?
스트림은 데이터소스를 추상화하고, 데이터를 다루는데 자주 사용되는 메서드들을 정의해 놓았다.
- 데이터소스를 추상화하였다는 것은, 데이터 소스가 무엇이던 간에 같은 방식으로 다룰 수 있게 되었다는 것과 코드의 재사용성이 높아진다는 것을 의미한다.
- 스트림을 이용하면, 배열이나 컬렉션뿐만 아니라 파일에 저장된 데이터도 모두 같은 방식으로 다룰 수 있다.
~~~java
    String[] strArr = {"aaa","ddd","ccc"};
    List<String> strList = Arrays.asList(strArr);

    //위의 데이터 소스를 기반으로 하는 스트림을 생성하자.
    Stream<String> strStream = strList.stream(); //스트림을 생성

    //이 스트림으로 데이터소스의 데이터를 읽어서 정렬하고 화면에 출력해보자.
    strSteam.sorted().forEach(System.out::println);

    //스트림을 사용하지 않고 코드를 작성했다면 아래와 같다.
    Collections.sort(strList);

    for(String str : strList)
        System.out.println(str);
~~~
코드로 작성해본것 처럼 스트림을 사용한 코드가 간결하고 이해하기 쉬우며 재사용성도 높다는 것을 알 수 있다.


### **스트림은 데이터 소스를 변경하지 않는다.**
그리고 스트림은 데이터 소스로부터 데이터를 읽기만할 뿐, 데이터 소스를 변경하지 않는다는 차이가 있다.
- 필요하다면, 정렬된 결과를 컬렉션이나 배열에 담아서 반환할 수도 있다.

### **스트림은 일회용이다.**
스트림은 Iterator처럼 일회용이다. Iterator로 컬렉션의 요소를 모두 읽고 나면 다시 사용할 수 없는 것처럼, 스트림도 한 번 사용하면 닫혀서 다시 사용할 수 없다. 필요하다면 스트림을 다시 생성해야한다.

### **스트림은 작업을 내부 반복으로 처리한다.**
스트림을 이용한 작업이 간결할 수 있는 비결중의 하나가 바로 '내부 반복'이다.
- 내부 반복이라는 것은 반복문을 메서드의 내부에 숨길 수 있다는 것을 의미한다.
- forEach()는 스트림에 정의된 메서드 중의 하나로 매개변수에 대입된 람다식을 데이터 소스의 모든 요소에 적용한다.
~~~java
    for(String str : strList)
        System.out.println(str);

    //메서드 참조 System.out::println를 람다식으로 표현하면
    //(str) -> System.out.println(str)과 같다.
    stream.forEach(System.out::println);
~~~

## 스트림의 연산
스트림이 제공하는 다양한 연산을 이용해서 복잡한 작업들을 간단히 처리할 수 있다.
- 마치 데이터베이스에 SELECT문으로 질의(쿼리, query)하는 것과 같은 느낌이다.
- 중간연산 : 연산결과가 스트림인 연산, 스트림에 연속해서 중간연산할 수 있다.
- 최종연산 : 연산결과가 스트림이 아닌 연산, 스트림의 요소를 소모하므로 단 한번만 가능하다.

### **지연된 연산**
스트림에서 한 가지 중요한 점은 최종 연산이 수행되기 전까지는 중간연산이 수행되지 않는다는 것이다.
- 중간 연산을 호출해도 즉각적인 연산이 수행되는 것이 아니다.
- 중간 연산을 호출하는 것은 단지 어떤 작업이 수행되어야하는지를 지정해주는 것일 뿐이다.
> 최종연산이 수행되어야 비로소 스트림의 요소들이 중간 연산을 거쳐 최종 연산에서 소모된다.

### **병렬 스트림**
스트림으로 데이터를 다룰 때의 장점 중 하나가 바로 병렬 처리가 쉽다는 것이다.
- 병렬 스트림은 내부적으로 fork&join프레임워크를 이용해서 자동적으로 연산을 병렬로 수행한다.
- 스트림에 parallel()이라는 메서드를 호출해서 병렬로 연산을 수행하도록 지시하면 될 뿐이다.
- 반대로 병렬로 처리되지 않게 하려면 sequential()을 호출하면 된다.  
    - 참고로 모든 스트림은 기본적으로 병렬 스트림이 아니므로 sequential()을 호출할 필요가 없고, parallel()을 호출한 것을 취소할 때만 사용한다.

## 스트림 만들기
스트림의 소스가 될 수 있는 대상은 배열, 컬렉션, 임의의 수 등 다양하다.

### **컬렉션**
컬렉션의 최고 조상인 Collection에 stream()에 정의되어 있다.
그래서 Collecion의 자손인 List와 Set을 구현한 컬렉션 클래스들은 모두 이 메서드로 스트림을 생성할 수 있다.

```java
    Stream<T> Collection.stream()
```

### **배열**
배열을 소스로 하는 스트림을 생성하는 메서드는 Stream과 Arrays에 static메서드로 정의되어 있다.
```java
    Stream<T> Stream.of(T... values) //가변인자
    Stream<T> Stream.of(T[])
    Stream<T> Arrays.stream(T[])
    Stream<T> Arrays.stream(T[] array, int startInclusive, int endExculsive)
```
int, long, double과 같은 기본형 배열을 소스로 하는 스트림을 생성하는 메서드도 있다는 것을 참고로 알아두자.

### **특정 범위의 정수**
IntStream과 LongStream은 다음과 같이 지정된 범위의 연속된 정수를 스트림으로 생성해서 반환하는 range()와 rangeClose()를 가지고 있다.
```java
    IntStream IntStream.range(int begin, int end)
    IntStream IntStream.rangeClosed(int begin, int end)
```
- range()의 경우 경계의 끝인 end가 범위에 포함되지 않고, rangeClosed()의 경우는 포함된다.

### **임의의 수**
난수를 생성하는 Random클래스에는 해당 타입의 난수들로 이루어진 스트림을 반환하는 인스턴스 메서드들이 있다.
```java
    IntStream ints()
    LongStream longs()
    DoubleStream doubles()
```
이 메서드들이 반환하는 스트림은 크기가 정해지지 않은 **무한 스트림**이므로 limit()도 같이 사용해서 스트림의 크기를 제한해주도록 하자.
```java
    IntStream ints(long streamSize)
    LongStream longs(long streamSize)
    DoubleStream doubles(long streamSize)
```
또는 이처럼 매개변수로 스트림의 크기를 지정해주어서 **유한 스트림**을 생성해서 사용하여도 된다.
- 지정된 범위(begin~end)의 난수를 발생시키는 스트림을 얻는 메서드도 매개변수 int begin과 end를 추가하여 사용할 수 있다.
- 단, end는 포함되지 않는다. 

### **람다식 - iterate(), generate()**
이 두 메서드는 람다식을 매개변수로 받아서, 이 람다식에 의해 계산되는 값들을 요소로하는 무한 스트림을 생성한다.
```java
    static <T> Stream<T> iterate(T seed, UnaryOperator<T> f)
    static <T> Stream<T> generate(Supplier<T> s)
```
- iterate()는 seed로 지정된 값부터 시작해서, 람다식 f에 의해 계산된 결과를 다시 seed값으로 해서 계산을 반복한다.
- generate()도 람다식에 의해 계산되는 값을 요소로 하는 무한 무한 스트림을 생성해서 반환하지만, iterate()와 달리 이전 결과를 이용해서 다음 요소를 계산하지는 않는다.
- generate()는 Supplier타입이므로 매개변수가 없는 람다식만 가능하다.

### **빈 스트림**
요소가 하나도 없는 비어있는 스트림을 생성할 수도 있다.
- 스트림에 연산을 수행한 결과가 하나도 없을 때, null보다 빈 스트림을 반환하는 것이 낫다.
```java
    Stream emptySteam = Stream.empty();

    //참고로 count()는 스트림 요소의 개수를 반환한다.
```

### **두 스트림의 연결**
concat()을 이용하면 두 스트림을 연결할 수 있고, 당연히 연결하고자 하는 스트림의 요소는 같은 타입이여야 한다.
```java
    String[] str1 = {../*생략*/}
    String[] str2 = {../*생략*/}
    
    Stream<String> strs1 = Stream.of(str1);
    Stream<String> strs2 = Stream.of(str2);

    Stream<String> strs3 = Stream.concat(strs1,strs2);
```

## 스트림의 중간연산
### **스트림 자르기 - skip(), limit()**
skip(3)은 처음 3개의 요소를 건너 뛰고, limit(5)는 스트림의 요소를 5개로 제한한다.

### **스트림의 요소 걸러내기 - filter(), distinct()**
distinct()는 스트림에서 중복된 요소들을 제거하고, filter()는 주어진 조건(Predicate)에 맞지 않는 요소를 걸러낸다.

### **정렬 - sorted()**
스트림을 정렬할 때는 sorted()를 사용하면 된다.
- Comparator를 지정하지 않으면 스트림 요소의 기본 정렬 기준(Comparable)으로 정렬한다.
    
```