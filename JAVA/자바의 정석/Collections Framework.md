## 컬렉션 프레임워크

컬렉션 프레임워크이란, '데이터 군을 저장하는 클래스들을 표준화한 설계'를 뜻한다.
컬렉션(Collection)은 다수의 데이터, 즉 데이터 그룹을, 프레임웍은 표준화된 프로그래밍 방식을 의미한다.
- 참고로 Java API 문서에서는 컬렉션 프레임웍을 '데이터 군(group)을 다루고 표현하기 위한 단일화된 구조'라고 정의한다.

### **컬렉션 프레임워크의 장점**
> **컬렉션 프레임웍은 컬렉션(다수의 데이터)을 다루는데 필요한 다양하고 풍부한 클래스들을 제공하**기 때문에 프로그래머의 짐을 상당히 덜어주고 있으며, 또한 인터페이스와 다형성을 이용한 객체 지향적 설계를 통해 표준화되어 있기 때문에 사용법을 익히기에도 편리하고 재사용성이 높은 코드를 작성할 수 있다.

## 컬렉션 프레임워크의 핵심 인터페이스
컬렉션 프레임웍에서는 컬렉션데이터 그룹을 크게 **3가지** 타입이 존재한다고 인식하고 각 컬렉션을 다루는데 필요한 기능을 가진 3개의 인터페이스를 정의하였다.
- 그리고 인터페이스 List와 Set의 공통된 부분을 다시 뽑아서 새로운 인터페이스인 Collection을 추가로 정의하였다.
- 인터페이스 List와 Set을 구현한 컬렉션 클래스들은 서로 많은 공통부분이 있어서, 공통된 부분을 다시 뽑아 Collection인터페이스를 정의할 수 있었지만, Map 인터페이스는 이들과는 전혀 다른 형태로 컬렉션을 다루기 때문에 같은 상속계층도에 포함되지 못했다.

### **List**
- 순서가 있는 데이터의 집합, 데이터의 중복을 허용한다.(ex : 대기자 명단)
- 구현 클래스 : ArrayList, LinkedList, Stack, Vector 등

### **Set**
- 순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지 않는다.
(ex : 양의 정수집합, 소수의 집합)
- 구현 클래스 : HashSet, TreeSet 등

### **Map**
- 키(key)와 값(value)의 쌍(pair)으로 이루어진 데이터의 집합
순서는 유지되지 않으며, 키는 중복을 허용하지 않고, 값은 중복을 허용한다.
(ex: 우편번호, 지역번호(전화번호))
- 구현 클래스 : HashMap, TreeMap, Hashtable, Properties 등

> 컬렉션 프레임워크의 모든 컬렉션 클래스들은 List, Set, Map 중의 하나를 구현하고 있으며, 구현한 인터페이스의 이름이 클래스의 이름에 포함되어 있어서 이름만으로도 클래스의 특징을 쉽게 알수 있도록 되어 있다.

> 하지만 Vector, Stack, Hashtable은 컬렉션 프레임워크가 만들어지기 이전부터 존재하던 것이기 때문에 컬렉션 프레임 워크의 명명법을 따르지 않는다.

참고로, Vector나 Hashtable 같은 기존의 컬렉션들은 가능한 사용하지 않고 대신 새로 추가된 ArrayList와 HashMap을 사용하도록 하자.

## List 인터페이스
List 인터페이스는 **중복을 허용면서 저장순서가 유지**되는 컬렉션을 구현하는데 사용된다.
### ✔️ **ArrayList**
ArrayList는 List인터페이스를 구현하기 때문에 데이터의 저장순서가 유지되고 중복을 허용한다는 특징을 갖는다.
- ArrayList는 기존의 Vector를 개선한 것으로  Vector와 구현원리와 기능적 측면에서 동일하다고 할 수 있다.
- ArrayList는 Object배열을 이용해서 데이터를 순차적으로 저장한다.
- 배열에 더 이상 저장할 공간이 없으면 보다 큰 새로운 배열을 생성해서 기존의 배열에 저장된 내용을 새로운 배열로 복사한 다음에 저장된다.

ArrayList나 Vector 같이 배열을 이용한 자료구조는 데이터를 읽어오고 저장하는데는 효율이 좋다.
> 하지만 배열은 크기를 한 번 정하면 바꿀 수 없기 때문에 용량을 변경해야할 때 **ArrayList와 Vector**는 새로운 배열을 저장한 후에 기존의 배열로 부터 새로 생성된 배열로 데이터를 복사해야하기 때문에 상당히 효율이 떨어진다는 단점을 가지고 있다.

> 또한, 차례대로 데이터를 추가하고 삭제하는 것은 빠르지만, 배열의 중간에 데이터를 추가하고 삭제하려면 다른 데이터들을 복사해서 이동해야해서 시간이 많이 걸린다.

처음에 인스턴스를 생성할 때, 저장할 데이터의 개수를 잘 고려하여 충분한 용량의 인스턴스를 생성하도록 하자.

### ✔️ **LinkedList**
위의 배열을 이용한 ArrayList와 Vector의 단점을 보완하기 위해서 [LinkedList](https://github.com/SeokHyeMin/TIL/blob/main/자료구조와%20알고리즘/연결리스트.md)라는 자료구조가 고안되었다.
- 배열은 모든 데이터가 연속적으로 존재하지만 링크드 리스트는 불연속적으로 존재하는 데이터를 서로 연결(link)한 형태로 구성되어 있다.
- 링크드 리스트의 각 요소(node)들은 자신과 연결된 다음 요소에 대한 참조(주소값)와 데이터로 구성되어 있다.
~~~java
class Node{
    Node next; //다음 요소의 주소를 저장
    Object obj; //데이터를 저장
}
~~~
> 링크드 리스트는 이동방향이 단방향이기 때문에 다음 요소에 대한 접근은 쉽지만 이전 요소에 대한 접근은 어렵다.

> 이 점을 보완한 것이 더블 링크드 리스트(이중 연결리스트, doubly linked list)이다.

#### **doubly linked list**
더블 링크드 리스트는 단순히 링크드 리스트에 참조변수를 하나 더 추가하여 다음요소에 대한 참조뿐만 아니라 이전 요소에 대한 참조가 가능하도록 했을 뿐, 그 외에는 링크드 리스트와 같다.
- 더블 링크드 리스트는 링크드 리스트보다 각 요소에 대한 접근과 이동이 쉽기 때문에 링크드 리스트보다 더 많이 사용된다.
~~~java
class Node{
    Node next; //다음 요소의 주소를 저장
    Node previous; //이전 요소의 주소를 저장
    Object obj; //데이터를 저장
}
~~~

#### **doubly circular linked list**
단순히 더블 링크드 리스트의 첫 번째 요소와 마지막 요소를 서로 연결시킨 것이다.
- 이렇게 하면 마지막 요소의 다음요소가 첫 번째 요소가 되고, 첫 번째 요소의 이전 요소가 마지막 요소가 된다.

📌 **실제로 LinkedList 클래스는 이름돠 달리 '링크드 리스트'가 아닌 '더블 링크드 리스트'로 구현되어 있는데, 이는 링크드 리스트의 낮은 접근성을 높이기 위한 것이다.**

|컬렉션|읽기(접근시간)|추가/삭제|비고|
|------|-------------|--------|----|
|ArrayList|빠르다|느리다|순차적인 추가,삭제는 더 빠르다. 비효율적으로 메모리를 사용한다.|
|LinkedList|느리다|빠르다.|데이터가 많을수록 접근성이 떨어진다.|

#### **정리**
다루고자 하는 데이터의 개수가 변하지 않는 경우라면, ArrayList가 최상의 선택이 되겠지만, 데이터 개수의 변경이 잦다면 LinkedList를 사용하는 것이 더 나은 선택이 될 것이다.
- 처음에 작업하기 전에 데이터를 저장할 때는 ArrayList를 사용한 다음, 작업할 때는 LinkedList로 데이터를 옮겨서 작업하면 좋은 효율을 얻을 수 있다.

## Stack과 Queue
스택은 마지막에 저장한 데이터를 가장 먼저 꺼내게 되는 LIFO 후입선출의 구조로 되어있고,
큐는 처음에 저장한 데이터를 가장 먼저 꺼내게 되는 FIFO 선입선출의 구조로 되어 있다.
- 순차적으로 데이터를 추가하고 삭제하는 스택은 ArrayList와 같은 배열기반의 컬렉션 클래스가 적합하다.
- 큐는 데이터를 꺼낼 때 마다 항상 첫 번째 저장된 데이터를 삭제하므로 ArrayList와 같은 배열기반의 컬렉션 클래스를 사용한다면 데이터를 꺼낼 때마다 빈 공간을 채우기 위해 데이터의 복사가 발생하므로 비효율 적이다.
- 그래서 큐는 ArrayList보다 데이터의 추가/삭제가 쉬운 LinkedList로 구현하는 것이 더 적합하다.
> 자바에서는 스택을 Stack 클래스로 구현하여 제공하고 있지만, 큐는 Queue인터페이스로만 정의해놓았을 뿐 별도의 클래스를 제공하고 있지않다. 대신 Queue인터페이스를 구현한 클래스들이 있어서 이 들 중의 하나를 선택해서 사용하면 된다.

### 스택과 큐의 활용
우리가 쉽게 찾아볼 수 있는 스택과 큐의 활용 예
- 스택의 활용 예 : 수식계산, 수식괄호검사, 워드프로세서의 undo/redo, 웹브라우저의 뒤로/앞으로
- 큐의 활용 예 : 최근사용문서, 인쇄작업 대기목록, 버퍼(buffer)

### PriorityQueue
Queue인터페이스의 구현체 중의 하나로, 저장한 순서에 관계없이 우선순위(priority)가 높은 것부터 꺼내게 된다는 특징이 있다.
- null은 저장할 수 없으며, null을 저장하면 NullPointException이 발생한다.
- PriorityQueue는 저장공간으로 배열을 사용하며, 각 요소를 '힙(heap)'이라는 자료구조의 형태로 저장한다.
- 예를 들어 숫자를 저장할 경우에, 저장한 순서와 상관없이 우선순위에 따라 내부적으로 정렬되어 저장된다.(우선순위는 숫자가 작을수록 높기 때문에 작은 수 부터 저장된다.)

### Deque(Double - Ended Queue)
Queue의 변형으로, 한 쪽 끝으로만 추가/삭제할 수 있는 Queue와 달리, Dequeue(덱, 또는 디큐라고 읽는다.)은 양쪽 끝에 추가/삭제가 가능하다.
- Dequeue의 조상은 Queue이며, 구현체로는 ArrayDeque와 LinkedList 등이 있다.
- **덱은 스택과 큐를 하나로 합쳐놓은 것과 같으며 스택으로 사용할 수 있고, 큐로 사용할수도 있다.**

## Iterator, ListIterator, Enumeration
Iterator, ListIterator, Enumeration은 모두 컬렉션에 저장된 요소를 접근하는데 사용되는 인터페이스이다. Enumeration은 Iterator의 구버전이며, ListIterator는 Iterator의 기능을 향상 시킨것이다.

### ✔️ **Iterator**
컬렉션에 저장된 각 요소에 접근하는 기능을 가진 Iterator인터페이스를 정의하고, Collection인터페이스에는 'Iterator(Iterator를 구현한 클래스의 인스턴스)'를 반환하는 iterator()를 정의하고 있다.
~~~java
    public interface Iterator{
        boolean hasNext();
        Object next();
        void remove();
    }

    public interface Collection{
        ...
        public Iterator iterator();
        ...
    }
~~~
- iterator()는 Collection인터페이스에 정의된 메서드이므로, Collection 인터페이스의 자손인 List와 Set에도 포함되어 있다.
- 그래서 List나 Set인터페이스를 구현하는 컬렉션은 iterator()가 각 컬렉션의 특징에 알맞게 작성되어 있다.

|메서드|설명|
|---------|----|
|boolean hasNext()|읽어 올 요소가 남아있는지 확인한다. 있으면 true, 없으면 false를 반환한다.|
|Object next()|다음 요소를 읽어온다. next()를 호출하기 전에 hasNext()를 호출해서 읽어 올 요소가 있는지 확인하는 것이 안전하다.|
|void remove()|next()로 읽어 온 요소를 삭제한다. next()를 호출한 다음에 remove()를 호출해야한다.(선택적 기능)|

### ✔️ **ListIterator와 Enumeration**
Enumeration은 컬렉션 프레임워크가 만들어지기 이전에 사용하던 것으로 Iterator의 구버전이므로 가능하면 Itertor를 사용하자.

ListIterator는 Iterator를 상속받아서 기능을 추가한 것으로, 컬렉션의 요소에 접근할 때 Iterator는 단방향으로만 이동할 수 있는데 반해 ListIterator는 양방향으로의 이동이 가능하다.
다만, ArrayList나 LinkedList 같이 List 인터페이스를 구현한 컬렉션에서만 사용할 수 있다.
> Enumerataion : Iterator의 구버전

> ListIterator : Iterator에 양방향 조회기능 추가(List를 구현한 경우만 사용가능하다.), Iterator에 이전방향으로의 접근기능을 추가한 것이다.

## Arrays
Arrays클래스에는 배열을 다루는데 우용한 메서드가 정의되어 있다. 같은 기능의 메서드가 배열의 타입만 다르게 오버로딩되어 있어서 많아 보이지만, 실제로는 그리 많지 않다.

#### **배열의 복사 - copyOf(), copyOfRange()**
copyOf()는 배열 전체를, copyOfRange()는 배열의 일부를 복사해서 새로운 배열을 만들어 반환한다.
- copyOfRange()에 지정된 범위의 끝은 포함되지 않는다.
~~~java
    int[] arr = {0,1,2,3,4}
    int[] arr2 = Arrays.copyOf(arr, 3); //arr2={0,1,2}
    int[] arr3 = Arrays.copyOfRange(arr, 2, 4); //arr3={2,3} 4는 불포함
~~~
#### **배열 채우기 - fill(), setAll()**
fill()은 배열의 모든 요소를 지정된 값으로 채운다. setAll()은 배열을 채우는데 사용할 함수형 인터페이스를 매개변수로 받는다.
~~~java
    int[] arr = new int[5];
    Arrays.fill(arr,9); //arr[9,9,9,9,9]
    Arrays.setAll(arr, () -> (int)(Math.random()*5 + 1)); //arr=[1,5,2,1,1]
~~~

#### **배열의 정렬과 검색 - sort(), binarySearch()**
sort()는 배열을 정렬할 때, 그리고 배열에 저장된 요소를 검색할 때는 binarySearch()를 사용한다.
-  binarySearch()는 배열에서 지정된 값이 저장된 위치(index)를 찾아서 반환하는데, 반드시 배열이 **정렬된 상태이어야 올바른 결과**를 얻는다. (이진검색은 정렬됐을 경우만 사용가능.)
- 또한, 검색한 값과 일치하는 요소들이 여러 개 있다면, 이 중에서 어떤 것의 위치가 반환될지 알 수 없다.

#### **배열의 비교와 출력 - equals(), toString()**
toString()은 배열의 모든 요소를 문자열로 편하게 출력할 수 있다.

equals()는 두 배열에 저장된 모든 요소를 비교해서 같으면 true, 다르면 false를 반환한다.
- toString()는 일차원 배열에만 사용할 수 있으며, 다차원 배열에는 deepToString()을 사용해야한다.
- deepToString()은 배열의 모든 요소를 재귀적으로 접근해서 문자열을 구성하기 때문에 3차원 이상의 배열에서도 동작한다.
- eqauls()도 일차원 배열에만 사용할 수 있으므로, 다차원 배열의 비교에는 deepEquals()를 사용해야한다.

#### **배열을 List로 변환 - asList(Object... a)**
asList()는 배열을 List에 담아서 반환한다. 매개변수의 타입이 가변인수라서 배열 생성없이 저장할 요소들만 나열하는 것도 가능하다.
~~~java
    List list = Arrays.asList(new Integer[]{1,2,3,4}); //list=[1,2,3,4]
    List list = Arrays.asList(1,2,3,4); //list=[1,2,3,4]

    //UnsupportedOperationException예외 발생
    list.add(6);
~~~

📌 **주의할 점**
asList()가 반환한 List는 크기를 변경할 수 없다. (추가, 또는 삭제가 불가능하다.)
저장된 내용을 변경하는 것은 가능하며, 배열을 크기를 변경할 수 있는 List로 생성하고 싶다면 아래와 같이 하면 된다.
~~~java
    List list = new ArrayList(Arrays.asList(1,2,3,4));
~~~

#### **parallel(), spliterator(), stream()**
'parallel()'로 시작하는 이름의 메서드들이 있는데, 이 메서드들은 보다 빠른 결과를 얻기 위해서 여러 쓰레드가 작업을 나누어 처리하도록 한다.

spiterator()는 여러 쓰레드가 처리할 수 있게 하나의 작업을 여러 작업으로 나누는 Spliterator를 반환한다.

stream()은 컬렉션을 스트림으로 변환한다.

## Comparator와 Comparable
Arrays.sort()를 호출만 하면 컴퓨터가 알아서 배열을 정렬하는 것처럼 보이지만, 사실은 Character클래스의 Comparable의 구현에 의해 정렬되었던 것이다.
- **Comparator와 Comparable은 모두 인터페이스**로 컬렉션을 정렬하는데 필요한 메서드를 정의하고 있다.
-  Comparable을 구현하고 있는 클래스들은 같은 타입의 인스턴스끼리 서로 비교할 수 있는 클래스들, 주로 Integer와 같은 wrapper클래스와 String, Date, File과 같은 것들이며 기본적으로 오름차순, 즉 작은 값에서부터 큰 값의 순으로 정렬되도록 구현되어 있다.
~~~java
    /* Comparator와 Comparable 실제 소스*/
    public interface Comparator{
        int compare(Object o1, Object o2);
        boolean equals(Object obj);
    }

    public interface Comparable{
        public int compareTo(Object o);
    }
~~~
- compare()와 compareTo()는 선언형태와 이름이 약간 다를 뿐 두 객체를 비교한다는 같은 기능을 목적으로 고안된 것이다.
- compareTo()의 반환값은 int로, 비교하는 두 객체가 같으면 0, 비교하는 값보다 작으면 음수, 크면 양수를 반환하도록 구현해야한다.
- 이와 마찬가지로 compare()도 객체를 비교해서 음수, 0, 양수 중의 하나를 반환하도록 구현해야한다.
- Comparable을 구현한 클래스들이 기본적으로 오름차순으로 정렬되어 있지만, 내림차순으로 정렬한다던가 아니면 다른 기준에 의해서 정렬되도록 하고 싶을 때 Comparator를 구현해서 정렬기준을 제공할 수 있다.
> Comparable : 기본 정렬기준을 구현하는데 사용
> Comparator : 기본 정렬기준 외에 다른 기준으로 정렬하고자할 때 사용한다.

## HashSet
HashSet은 Set인터페이스를 구현한 가장 대표적인 컬렉션이다.
- Set인터페이스의 특징대로 HashSet은 중복된 요소를 저장하지 않는다.
- 저장순서를 유지하지 않으므로 **중복을 제거하는 동시에 저장한 순서를 유지히고자 한다면 LinkedHashSet을 사용**해야한다.
- add메서드나 addAll 메서드를 사용해서 데이터를 추가하는데, 객체를 추가할 때 HashSet에 이미 같은 객체가 있으면 중복으로 간주하고 더 저장하지 않는다.(false반환)

> HashSet의 add메서드는 새로운 요소를 추가하기 전에 기존에 저장된 요소와 같은 것인지 판별하기 위해 추가하려는 요소의 equals()와 hashCode()를 호출하기 때문에 equals()와 hashCode()를 목적에 맞게 오버라이딩하여 쓰면된다.

> 두 객체에 대해 equals메서드를 호출한 결과가 true이면, 두 객체의 해시코드는 반드시 같아야하지만, 두 객체의 해시코드가 같다고 해서 equals메서드의 호출결과가 반드시 true이어야 하는 것은 아니다.

## TreeSet
TreeSet은 이진 검색 트리(binary search tree)라는 자료구조의 형태로 데이터를 저장하는 컬렉션 클래스이다.
- 이진 검색 트리는 정렬, 검색, 범위검색(range search)에 높은 성능을 보이는 자료구조이다.
- TreeSet은 이진 검색 트리의 성능을 향상 시킨 '레드-블랙-트리(Red-Black tree)'로 구현되어 있다.
- 이진 검색 트리는 부모노드의 왼쪽에선 부모노드의 값보다 작은 값의 자식 노드를 오른쪽에는 큰 값의 자식노드를 저장하는 이진 트리이다.

> Set 인터페이스를 구현했으므로, 중복된 데이터의 저장을 허용하지 않으며 정렬된 위치에 저장하므로 저장순서를 유지하지도 않는다.

### 이진 검색 트리 (binary search tree)
- 모든 노드는 최대 두 개의 자식 노드를 가질 수 있다.
- 왼쪽 자식노드의 값은 부모노드의 값보다 작고 오른쪽자식 노드의 값은 부모노드의 값보다 커야한다.
- 노드의 추가 삭제에 시간이 걸린다.(순차적으로 저장하지 않으므로)
- 검색(범위검색)과 정렬에 유리하다.
- 중복된 값을 저장하지 못한다.

> 참고로 문자열의 경우 정렬순서는 문자의 코드값이 기준이 되므로, 오름차순의 정렬의 경우 코드값의 크기가 작은 순서에서 큰 순서, 공백, 숫자, 대문자, 소문자 순으로 정렬되고 내림차순의 경우 반대이다.