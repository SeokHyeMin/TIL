## 컬렉션 프레임워크

컬렉션 프레임워크이란, '데이터 군을 저장하는 클래스들을 표준화한 설계'를 뜻한다.
컬렉션(Collection)은 다수의 데이터, 즉 데이터 그룹을, 프레임웍은 표준화된 프로그래밍 방식을 의미한다.
- 참고로 Java API 문서에서는 컬렉션 프레임웍을 '데이터 군(group)을 다루고 표현하기 위한 단일화된 구조'라고 정의한다.

### **컬렉션 프레임워크의 장점**
> **컬렉션 프레임웍은 컬렉션(다수의 데이터)을 다루는데 필요한 다양하고 풍부한 클래스들을 제공하**기 때문에 프로그래머의 짐을 상당히 덜어주고 있으며, 또한 인터페이스와 다형성을 이용한 객체 지향적 설계를 통해 표준화되어 있기 때문에 사용법을 익히기에도 편리하고 재사용성이 높은 코드를 작성할 수 있다.

## 컬렉션 프레임워크의 핵심 인터페이스
컬렉션 프레임웍에서는 컬렉션데이터 그룹을 크게 **3가지** 타입이 존재한다고 인식하고 각 컬렉션을 다루는데 필요한 기능을 가진 3개의 인터페이스를 정의하였다.
- 그리고 인터페이스 List와 Set의 공통된 부분을 다시 뽑아서 새로운 인터페이스인 Collection을 추가로 정의하였다.
- 인터페이스 List와 Set을 구현한 컬렉션 클래스들은 서로 많은 공통부분이 있어서, 공통된 부분을 다시 뽑아 Collection인터페이스를 정의할 수 있었지만, Map 인터페이스는 이들과는 전혀 다른 형태로 컬렉션을 다루기 때문에 같은 상속계층도에 포함되지 못했다.

### **List**
- 순서가 있는 데이터의 집합, 데이터의 중복을 허용한다.(ex : 대기자 명단)
- 구현 클래스 : ArrayList, LinkedList, Stack, Vector 등

### **Set**
- 순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지 않는다.
(ex : 양의 정수집합, 소수의 집합)
- 구현 클래스 : HashSet, TreeSet 등

### **Map**
- 키(key)와 값(value)의 쌍(pair)으로 이루어진 데이터의 집합
순서는 유지되지 않으며, 키는 중복을 허용하지 않고, 값은 중복을 허용한다.
(ex: 우편번호, 지역번호(전화번호))
- 구현 클래스 : HashMap, TreeMap, Hashtable, Properties 등

> 컬렉션 프레임워크의 모든 컬렉션 클래스들은 List, Set, Map 중의 하나를 구현하고 있으며, 구현한 인터페이스의 이름이 클래스의 이름에 포함되어 있어서 이름만으로도 클래스의 특징을 쉽게 알수 있도록 되어 있다.

> 하지만 Vector, Stack, Hashtable은 컬렉션 프레임워크가 만들어지기 이전부터 존재하던 것이기 때문에 컬렉션 프레임 워크의 명명법을 따르지 않는다.

참고로, Vector나 Hashtable 같은 기존의 컬렉션들은 가능한 사용하지 않고 대신 새로 추가된 ArrayList와 HashMap을 사용하도록 하자.

## List 인터페이스
List 인터페이스는 **중복을 허용면서 저장순서가 유지**되는 컬렉션을 구현하는데 사용된다.
### ✔️ **ArrayList**
ArrayList는 List인터페이스를 구현하기 때문에 데이터의 저장순서가 유지되고 중복을 허용한다는 특징을 갖는다.
- ArrayList는 기존의 Vector를 개선한 것으로  Vector와 구현원리와 기능적 측면에서 동일하다고 할 수 있다.
- ArrayList는 Object배열을 이용해서 데이터를 순차적으로 저장한다.
- 배열에 더 이상 저장할 공간이 없으면 보다 큰 새로운 배열을 생성해서 기존의 배열에 저장된 내용을 새로운 배열로 복사한 다음에 저장된다.

ArrayList나 Vector 같이 배열을 이용한 자료구조는 데이터를 읽어오고 저장하는데는 효율이 좋다.
> 하지만 배열은 크기를 한 번 정하면 바꿀 수 없기 때문에 용량을 변경해야할 때 **ArrayList와 Vector**는 새로운 배열을 저장한 후에 기존의 배열로 부터 새로 생성된 배열로 데이터를 복사해야하기 때문에 상당히 효율이 떨어진다는 단점을 가지고 있다.

> 또한, 차례대로 데이터를 추가하고 삭제하는 것은 빠르지만, 배열의 중간에 데이터를 추가하고 삭제하려면 다른 데이터들을 복사해서 이동해야해서 시간이 많이 걸린다.

처음에 인스턴스를 생성할 때, 저장할 데이터의 개수를 잘 고려하여 충분한 용량의 인스턴스를 생성하도록 하자.

### ✔️ **LinkedList**
위의 배열을 이용한 ArrayList와 Vector의 단점을 보완하기 위해서 [LinkedList](https://github.com/SeokHyeMin/TIL/blob/main/자료구조와%20알고리즘/연결리스트.md)라는 자료구조가 고안되었다.
- 배열은 모든 데이터가 연속적으로 존재하지만 링크드 리스트는 불연속적으로 존재하는 데이터를 서로 연결(link)한 형태로 구성되어 있다.
- 링크드 리스트의 각 요소(node)들은 자신과 연결된 다음 요소에 대한 참조(주소값)와 데이터로 구성되어 있다.
~~~java
class Node{
    Node next; //다음 요소의 주소를 저장
    Object obj; //데이터를 저장
}
~~~
> 링크드 리스트는 이동방향이 단방향이기 때문에 다음 요소에 대한 접근은 쉽지만 이전 요소에 대한 접근은 어렵다.

> 이 점을 보완한 것이 더블 링크드 리스트(이중 연결리스트, doubly linked list)이다.

#### **doubly linked list**
더블 링크드 리스트는 단순히 링크드 리스트에 참조변수를 하나 더 추가하여 다음요소에 대한 참조뿐만 아니라 이전 요소에 대한 참조가 가능하도록 했을 뿐, 그 외에는 링크드 리스트와 같다.
- 더블 링크드 리스트는 링크드 리스트보다 각 요소에 대한 접근과 이동이 쉽기 때문에 링크드 리스트보다 더 많이 사용된다.
~~~java
class Node{
    Node next; //다음 요소의 주소를 저장
    Node previous; //이전 요소의 주소를 저장
    Object obj; //데이터를 저장
}
~~~

#### **doubly circular linked list**
단순히 더블 링크드 리스트의 첫 번째 요소와 마지막 요소를 서로 연결시킨 것이다.
- 이렇게 하면 마지막 요소의 다음요소가 첫 번째 요소가 되고, 첫 번째 요소의 이전 요소가 마지막 요소가 된다.

📌 **실제로 LinkedList 클래스는 이름돠 달리 '링크드 리스트'가 아닌 '더블 링크드 리스트'로 구현되어 있는데, 이는 링크드 리스트의 낮은 접근성을 높이기 위한 것이다.**

|컬렉션|읽기(접근시간)|추가/삭제|비고|
|------|-------------|--------|----|
|ArrayList|빠르다|느리다|순차적인 추가,삭제는 더 빠르다. 비효율적으로 메모리를 사용한다.|
|LinkedList|느리다|빠르다.|데이터가 많을수록 접근성이 떨어진다.|

#### **정리**
다루고자 하는 데이터의 개수가 변하지 않는 경우라면, ArrayList가 최상의 선택이 되겠지만, 데이터 개수의 변경이 잦다면 LinkedList를 사용하는 것이 더 나은 선택이 될 것이다.
- 처음에 작업하기 전에 데이터를 저장할 때는 ArrayList를 사용한 다음, 작업할 때는 LinkedList로 데이터를 옮겨서 작업하면 좋은 효율을 얻을 수 있다.

