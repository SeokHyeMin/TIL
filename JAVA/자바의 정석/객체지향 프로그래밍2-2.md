## 다형성

### 다형성이란?

객체지향 개념에서 다형성이란 '여러 가지 형태를 가질 수 있는 능력'을 의미하며, 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현하였다.
- 조상 클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 하였다는 것이다.

Tv와 CpationTv클래스가 서로 상속관계에 있을 경우, 다음과 같이 조상 클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조하도록 하는 것도 가능하다.
~~~java
    Tv t = new CaptionTv(); //조상 타입의 참조변수로 자손 인스턴스를 참조.
    CaptionTv c = new CaptionTv();
~~~
- 위의 경우에서 실제 인스턴스가 CaptionTv타입이라 할지라도, 참조변수 t로는 CaptionTv인스턴스의 모든 멤버를 사용할 수 없다.
- Tv타입의 참조변수로는 CaptionTv인스턴스 중에서 Tv클래스의 멤버들(상속받은 멤버 포함)만 사용할 수 있다.
- 따라서, 생성된 CaptionTv인스턴스의 멤버중에서 Tv클래스에 정의되지 않은 멤버는 참조변수 t로 사용이 불가능하다.

📌 **둘 다 같은 타입의 인스턴스지만 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라진다.**

#### 그럼 자손타입의 참조변수로 조상타입의 인스턴스를 참조하는 것은 가능할까?
- 답은 불가능하다.
- 그 이유는 자손타입의 참조변수로 조상타입의 인스턴스를 참조하는 것은 존재하지 않는 멤버를 사용하고자 할 가능성이 있으므로 허용하지 않는다.
- **즉, 그렇기 때문에 참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 같거나 적어야한다.**
- 참조변수의 타입이 참조변수가 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 개수를 결정한다는 사실을 이해하는 것은 매우 중요하다.

> 조상 타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.

> 반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없다.

### 참조변수의 형변환
기본형 변수와 같이 참조형 변수도 형변환이 가능하다.
- 단 서로 **상속관계에 있는 클래스 사이에서만 가능**하다.
- 자손타입의 참조변수를 조상타입의 참조변수로, 조상타입의 참조변수를 자손타입의 참조변수로의 형변환만 가능하다.
    - 자손타입 -> 조상타입(Up-casting) : 형변환 생략가능.
    - 자손타입 <- 조상타입(Down-casting) : 형변환 생략불가.
- 업캐스팅의 경우 형변환이 생략가능한 이유는 참조변수가 다룰 수 있는 멤버의 개수가 실제 인스턴스가 갖고 있는 멤버의 개수보다 적을 것이 분명하므로 문제가 되지 않는다. 그래서 형변환을 생략할 수 있도록 한 것이다.
- 형변환은 참조변수의 타입을 변환하는 것이지 인스턴스를 변환하는 것은 아니기 때문에 참조변수의 형변환은 인스턴스에 아무런 영향을 미치지 않는다.
- 단지 참조변수의 형변환을 통해서, 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위(개수)를 조절하는 것 뿐이다.
> 서로 상속관계에 있는 타입간의 형변환은 양방향으로 자유롭게 수행될 수 있으나, 참조변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용되지 않는다.
그래서 참조변수가 가리키는 인스턴스의 타입이 무엇인지 확인하는 것이 중요하다.

### instance of 연산자
참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 instanceof 연산자를 사용한다.
- 주로 조건문에 사용되며, instanceof의 왼쪽에는 참조변수를 오른쪽에는 타입(클래스명)이 피연산자로 위치한다.
- 그리고 연산의 결과로 boolean값인 true와 false 중의 하나를 반환한다.
- **연산결과로 true를 얻었다는 것은 참조변수가 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.**
- 실제 인스턴스와 같은 타입의 instanceof연산 이외에 조상타입의 instanceof연산에도 true를 결과로 얻으며, instanceof연산의 결과가 true라는 것은 검사한 타입으로의 형변환을 해도 아무런 문제가 없다는 뜻이다.

### 참조변수와 인스턴스의 연결
조상타입의 참조변수와 자손 타입의 참조변수의 차이점이 사용할 수 있는 멤버의 개수에 있다고 하였다. 그리고 여기서 한 가지 더 알아두어야할 내용이 있다.
- 조상 클래스에 선언된 멤버변수와 같은 이름의 인스턴스변수를 자손 클래스에 중복으로 정의했을 때, 조상타입의 참조변수로 자손 인스턴스를 참조하는 경우와 자손타입의 참조변수로 자손 인스턴스를 참조하는 경우는 서로 다른 결과를 얻는다.
- 메서드의 경우 조상 클래스의 메서드를 자손 클래스에서 오버라이딩한 경우에도 참조 변수의 타입에 관계 없이 항상 실제 인스턴스 메서드(오버라이딩된 메서드)가 호출되지만, **멤버 변수의 경우 참조변수의 타입에 따라 달라진다.**

> 멤버변수가 조상 클래스와 자손클래스에 중복으로 정의된 경우, 조상타입의 참조변수를 사용했을 때는 조상 클래스에 선언된 멤버변수가 사용되고, 자손타입의 참조변수를 사용했을 때는 자손 클래스에 선언된 멤버변수가 사용된다.
~~~java
class Test{
    public static void main(String[] args){
        Parent p = new Child();
        Child c = new Child();

        System.out.println(p.x); //100
        System.out.println(c.x); //200
        
    }
}
class Parent{
    int x = 100;
}
class Child extends Parent{
    int x = 200;
}
~~~
- 메서드는 상관이 없고, 멤버변수일 때 해당한다는 것을 기억해두자.
- 이렇게 인스턴스 변수에 직접 접근하면, 참조변수의 타입에 따라 사용되는 인스턴스 변수가 달라질 수 있으므로 **멤버변수들은 주로 private으로 접근을 제한하고, 외부에서는 메서드를 통해서만 멤버변수에 접근할 수 있도록 해야한다.**

### 매개변수의 다형성
참조변수의 다향적인 특징은 메서드의 매개변수에도 적용된다.
~~~java
    void buy(Product p){
        money = money - p.price;
        bonusPoint = bonusPoint + p.bonusPoint;
    }
~~~
위의 예제와 같이 매개변수가 Product타입의 참조변수라는 것은, 메서드의 매개변수로 Product클래스의 자손타입의 참조변수면 어느 것이나 매개변수로 받아들일 수 있다는 뜻이다.

### 여러 종류의 객체를 배열로 다루기
조상타입의 참조변수 배열을 사용하면, 공통의 조상을 가진 서로 다른 종류의 객체를 배열로 묶어서 다룰 수 있다.
- 묶어서 다루고 싶은 객체들의 상속관계를 따져서 가장 가까운 공통조상 클래스 타입의 참조변수 배열을 생성해서 객체들을 저장하면 된다.
~~~java
    //Product가 Tv, Computer, Audio의 조상일 때, 조상 타입의 참조변수로 자손타입 객체를 참조하는 것 가능.
    Product p1 = new Tv():
    Product p2 = new Computer();
    Product p3 = new Audio():

    //위의 코드를 Product 타입의 참조변수 배열로 처리
    Product p[] = new Product[3];
    p[0] = new Tv();
    p[1] = new Computer();
    p[2] = new Audio();
~~~

## 추상클래스(abstract class)
### **추상 클래스란?**
클래스를 설계도에 비유한다면, 추상 클래스는 미완성 설계도에 비유할 수 있다.
- 클래스가 미완성이라는 것은 멤버의 개수에 관계된 것이 아니라, 단지 미완성 메서드(추상메서드)를 포함하고 있다는 의미이다.
- 미완성 설계도로 완성된 제품을 만들 수 없듯이 추상클래스로 인스턴스는 생성할 수 없다.
- 추상클래스는 상속을 통해서 자손클래스에 의해서만 완성될 수 있다.
- **추상 클래스는 키워드 'abstract'를 붙이기만 하면 된다.**
~~~java
    abstract class 클래스이름{
        ...
    }
~~~
- 추상 클래스는 추상메서드를 포함하고 있는 것을 제외하고는 일반클래스와 전혀 다르지 않다.
- 추상 클래스에도 생성자가 있으며, 멤버변수와 메서드도 가질 수 있다.

> 추상메서드를 포함하고 있지 않은 클래스에도 키워드 'abstract'를 붙여서 추상클래스로 지정할 수 있다. 추상메서드가 없는 완성된 클래스라 할지라도 추상 클래스로 지정되면 **클래스의 인스턴스를 생성할 수 없다.**

### **추상메서드(abstract method)**
선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 것이 추상메서드이다.
설계만 해 놓고 실제 수행될 내용은 작성하지 않았기 때문에 미완성 메서드인 것이다.
- 미완성 상태로 남겨 놓는 이유는 메서드의 내용이 상속받는 클래스에 따라 달라질 수 있기 때문에 조상 클래스에서는 선언부만을 작성하고, 주석을 덧붙여 어떤 기능을 수행할 목적으로 작성되었는지 알려주고, 실제 내용은 상속받는 클래스에서 구현하도록 비워두는 것이다.
- 추상메서드 역시 키워드 'abstract'를 앞에 붙여주고, 추상 메서드는 구현부가 없으므로 괄호{}대신 문장의 끝을 알리는 ';'을 적어준다.
~~~java
    //주석을 통해 어떤 기능을 수행할 목적으로 작성하였는지 설명한다.
    abstract 리턴타입 메서드이름();

~~~
> 추상클래스로부터 상속받는 자손클래스는 오버라이딩을 통해 조상인 추상클래스의 추상 메서드를 **모두** 구현해주어야 한다.
만일 조상으로부터 상속받은 추상메서드 중 하나라도 구현하지 않는다면, 자손 클래스 역시 추상 클래스로 지정해주어야한다.

### **추상클래스의 작성**
상속이 자손 클래스를 만드는데 조상 클래스를 사용하는 것이라면, 이와 반대로 **추상화는 기존의 클래스의 공통부분을 뽑아내서 조상 클래스를 만드는 것**이라고 할 수 있다.
- 추상화를 구체화와 반대되는 의미로 이해하면 보다 쉽게 이해할 수 있다.
- 상속계층도를 따라 내려 갈수록 세분화되며, 올라갈수록 공통요소만 남게 된다.
> 추상화 : 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업

> 구체화 : 상속을 통해 클래스를 구현, 확장하는 작업
- 굳이 abstract를 붙여서 추상메서드로 선언하는 이유는 자손 클래스에서 추상 메서드를 반드시 구현하도록 강요하기 위해서 이다.

