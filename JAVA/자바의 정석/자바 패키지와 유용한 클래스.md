# java.lang 패키지
java.lang패키지는 자바 프로그래밍에 가장 기본이 되는 클래스들을 포함하고 있다.
- 그렇기 때문에 java.lang 패키지의 클래스들은 import문 없이도 사용할 수 있게 되어 있다.
- String클래스나 System클래스를 import문 없이 사용할 수 있었던 이유이다.

## Object클래스
### **eqauls(Object obj)**
두 객체를 참조변수의 값으로 비교하여, 두 참조변수가 같은 객체를 참조하고 있는지, 즉 두 참조변수에 저장된 값(주소값)이 같은지를 판단한다.
- 주소가 아닌 객체에 저장된 내용을 비교하고 싶다면, equals메서드를 오버라이딩하여 변경하면 된다.
    - String클래스 역시 오버라이딩을 통해서 String인스턴스가 갖는 문자열 값을 비교하도록 되어 있다.

### **hashCode()**
해싱(hashing)기법에 사용되는 '해시함수(hash function)'를 구현한 것이다.
- 해싱은 데이터 관리기법 중의 하나인데, 다량의 데이터를 저장하고 검색하는데 유용하다.
- 해시함수는 찾고자하는 값을 입력하면, 그 값이 저장된 위치를 알려주는 해시코드(hash code)를 반환한다.
- 클래스의 인스턴스변수 값으로 객체의 같고 다름을 판단해야한다면, equals메서드와 hashCode둘다 적절히 오버라이딩해야한다.
- 같은 객체라면 hashCode메서드를 호출했을 때의 결과값인 해시코드도 같아야한다.

> String클래스는 문자열의 내용이 같으면, 동일한 해시코드를 반환하도록 hashCode()메서드가 오버라이딩 되어있다.

### **toString()**
인스턴스에 대한 정보를 문자열(String)로 제공할 목적으로 정의한 것이다.
- 인스턴스의 정보를 제공한다는 것은 대부분의 경우 인스턴스 변수에 저장된 값들을 문자열로 표현하다는 뜻이다.

Object클래스에 정의된 toString()이다.
```java
    public String toString(){
        return getClass.getName() + "@" + Integer.toHexString(hashCode());
    }
```
클래스를 작성할 때 toString()을 오버라이딩하지 않으면 위와 같은 내용이 그대로 사용될 것이며, toString()을 호출하면 **클래스이름**에 **16진수의 해시코드를** 얻게 될 것이다.

>String클래스의 toString()은 String인스턴스가 갖고 있는 문자열을 반환하도록 오버라이딩 되어 있고, Date클래스의 경우 Date인스턴스가 갖고 있는 날짜와 시간을 문자열로 변환하여 반환하도록 오버라이딩 되어 있다.

### **clone()**
자신을 복제하여 새로운 인스턴스를 생성하는 일을 하는 메서드이다.
- 원래의 인스턴스는 보존하고 clone메서드를 이용해서 새로운 인스턴스를 생성하여 작업을하면, 작업이전의 값이 보존되므로 작업을 실패하여 이전의 상태로 돌리고 싶을 때 유용하다.

```java
class Point implements Cloneable{

    public Object clone(){

        Object obj = null;
        try{
            obj = super.clone();
        }catch(CloneNotSupportedException e){

        }
        return obj;
    }
}
```
> clone()을 사용하려면, 복제할 클래스가 Cloneable인터페이스를 구현해야하며, 구현하지 않은 클래스내에서 호출되면 예외를 발생시킨다.

1. Cloneable인터페이스를 구현하자.(구현하는 이유는, 인스턴스의 데이터를 보호하기 위함이고, Cloneable인터페이스가 구현되어 있다는 것은 클래스 작성자가 복제를 허용한다는 의미이다.)
2. 접근제어자를 protected에서 public으로 변경하자.(그래야만 상속관계가 없는 다른 클래스에서 clone()을 호출할 수 있다.)
3. try-catch내에서 조상클래스의 clone()을 호출하자.(clone은 반드시 예외처리를 해주어야한다.)

#### 📌 **주의!**
- 단순히 인스턴스 변수의 값만 복사하기 때문에, 참조타입의 변수가 있는 클래스는 완전한 인스턴스 복제가 이루어 지지 않느다.
- 객체배열인 경우 복제된 인스턴스도 같은 배열의 주소를 갖기 때문에, 복제된 인스턴스의 작업이 원래의 인스턴스에 영향을 미치게 되므로, 이러한 경우는 clone메서드를 오버라이딩해서 새로운 배열을 생성하고 배열의 내용을 복사하도록 하자.

### **공변 반환타입**
JDK1.5부터 추가된 기능으로, 오버라이딩할 때 조상메서드의 반환타입을 자손 클래스의 타입으로 변경을 허용하는 것이다.

예를 들어,
```java
    public Point clone() { //clone의 반환타입은 원래 Object인데,   Point로 변경하였다.
        Object obj = null;
        try{
            obj = super.clone();
        }catch(CloneNotSupportedException e){

        }

        return (Point) obj; //Point타입으로 형변환
    }
```
'공변 반환타입'을 사용하면, 실제로 반환되는 자손객체의 타입으로 반환할 수 있어서 번거로운 형변환을 줄일 수 있다.

### **얕은 복사와 깊은 복사**
clone()은 단순히 객체에 저장된 값을 그대로 복제할 뿐, 객체가 참조하고 있는 객체까지 복제하지는 않는다.
- 예를 들어, 기본형 배열인 경우에는 아무런 문제가 없지만, 객체배열인 경우에 clone()으로 복제한다면 원본과 복제본이 같은 객체를 공유하므로 완전한 복제로 보기 어렵다.

✔️ 이러한 복제(복사)를 **얕은복사(shallow copy)라고 하며, 얕은 복사에서는 원본을 변경하면 복사본도 영향을 받는다.**

✔️ 반면에 원본이 참조하고 있는 객체까지 복사하는 것을 '깊은 복사(deep copy)'라고 한다. **깊은 복사에서는 원본과 복사본이 서로 다른 객체를 참조하기 때문에 원본의 변경이 복사본에 영향을 미치지 않는다.**

### getClass()
자신이 속한 클래스의 Class객체를 반환하는 메서드이다.
- Class객체는 이름이 'Class'인 클래스의 객체이다.
- **Class객체는 클래스의 모든 정보를 담고 있으며, 클래스당 1개만 존재한다.**
- 클래스 파일이 '클래스 로더(ClassLoader)'에 의해서 메모리에 올라갈 때, 자동으로 생성된다.
- 클래스 로더는 실행 시에 필요한 클래스를 동적으로 메모리에 로드하는 역할을 한다.
- 파일형태로 저장되어 있는 클래스 파일을 읽기 편한 형태로 저장해 놓은 것이 클래스 객체이다.
> 클래스 파일을 메모리에 로드하고 변환하는 일은 클래스 로더가 한다.

## String 클래스
### 변경 불가능한(immutable) 클래스
String 클래스에는 문자열을 저장하기 위해서 문자형 배열 참조변수(char[]) value를 인스턴스 변수로 정의해 놓고 있다.
- 인스턴스 생성 시 생성자의 매개변수로 입력받는 문자열은 이 인스턴스변수(value)에 문자형 배열(char[])로 저장된다.
- 한 번 생성된 String인스턴스가 갖고 있는 문자열은 읽어 올 수만 있고, 변경할 수는 없다.
- '+' 연산자로 문자열을 결합하는 경우 인스턴스내의 문자열이 바뀌는 것이 아니라 새로운 문자열이 담긴 String인스턴스가 생성되는 것이다.

이렇게 덧셈연산자'+'를 사용해서 문자열을 결합하는 것은 매 연산 시 마다 새로운 문자열을 가진 String인스턴스가 생성되어 메모리 공간을 차지하게 되므로 가능한 한 결합횟수를 줄이는 것이 좋다.

> 문자열간의 결합이나 추출 등 문자열을 다루는 작업이 많이 필요한 경우에는 String클래스 대신 StringBuffer클래스를 사용하는 것이 좋다. StringBuffer인스턴스에 저장된 문자열은 변경이 가능하기 때문에 하나의 StringBuffer인스턴스만으로 문자열을 다루는 것이 가능하다.

### 문자열 리터럴
자바 소스파일에 포함된 모든 문자열 리터럴은 컴파일 시에 **클래스 파일**에 저장된다.
- 이 때 같은 내용의 문자열 리터럴은 한번만 저장되는데, 문자열 리터럴도 String인스턴스이고, 한 번 생성하면 내용을 변경할 수 없기 때문에 하나의 인스턴스를 공유하면 된다. 

### join()과 StringJoiner
join()은 여러 문자열 사이에 구분자를 넣어서 결합한다. 구분자로 문자열을 자르는 split()과 반대의 작업을 한다고 생각하면 쉽다.
```java
    String animals = "dog,cat,bear";
    String[] arr = animals.split(","); //문자열을 ','로 나눠서 배열에 저장
    String str = String.join("-",arr); //배열의 문자열을 '-'로 구분해서 결합
```
java.util.StringJoiner클래스를 사용해서 문자열을 결합할 수도 있다.
```java
    StringJoiner sj = new StringJoiner("/", "[", "]");
    for(String s : arr){
        sj.add[(s);
    }
    System.out.println(sj); //[dog/cat/bear]
```

### 기본형 값을 String으로 변환
숫자에 빈 문자열" "을 더해주기만 하면 된다.
- 이외에 valueOf()를 사용하는 방법도 있다.
- 성능은 valueOf()가 더 좋지만, 빈 문자열을 더 하는 방법이 더 간단하고 편하기 때문에 성능 향상이 필요한 경우에만 valueOf()를 사용하자.
```java
    int i = 100;
    String str1 = i + "";
    String str2 = String.valueOf(i);
```

## StringBuffer클래스와 StringBuilder클래스
String클래스는 인스턴스를 생성할 때 지정된 문자열을 변경할 수 없지만 StringBuffer클래스는 변경이 가능하다.
- 내부적으로 문자열 편집을 위한 버퍼(buffer)를 가지고 있으며, StringBuffer인스턴스를 생성할 때 그 크기를 지정할 수 있다.
    - 이 때, 편집할 문자열의 크기를 고려하여 버퍼의 길이를 충분하게 잡아주지 않으면 버퍼의 길이를 늘려주는 작업이 추가로 필요할 수도 있으므로 작업 효율이 떨어지기 때문에 충분한 길이를 잡아주자.
- StringBuffer인스턴스를 생성할 때, 버퍼의 크기를 지정해주지 않으면 16개의 문자를 저장할 수 있는 크기의 버퍼를 생성한다.

StringBuffer클래스는 equals메서드를 오버라이딩하지 않아서 StringBuffer클래스의 equalse메서드를 사용해도 등가비교연산자(==)로 비교한것과 같은 결과를 얻는다.
- StringBuffer인스턴스에 담긴 문자열을 비교하기 위해서는 StringBuffer인스턴스에 toString()을 호출해서 String인스턴스를 얻은 다음, 여기에 equals메서드를 사용해서 비교해야한다.

### **StringBuilder란?**
StringBuilder는 멀티쓰레드에 안전하도록 동기화 되어 있다.
- 동기화는 StringBuffer의 성능을 떨어뜨리기 때문에, 멀티쓰레드로 작성된 프로그램이 아닌경우, StringBuffer의 동기화는 불필요하게 성능만 떨어뜨리게 된다.
- StringBuffer에서 쓰레드의 동기화만 뺀 StringBuilder가 새로 추가되었다.
- StringBuilder는 StringBuffer와 완전히 똑같은 기능으로 작성되어 있어서 소스코드에서 StringBuffer를 StringBuilder로 바꾸기만 하면 된다.
> StringBuffer도 충분히 성능이 좋기 때문에, 성능향상이 반드시 필요한 경우를 제외하고선 기존에 작성한 코드에서 굳이 바꿀 필요가 없다.

## Math클래스
### StrictMath클래스
Math클래스는 최대한의 성능을 얻기 위해 JVM이 설치된 OS의 메서드를 호출해서 사용한다.
- OS에 의존적인 계산을 하고 있는 것이다. OS마다 설정이 다른 것은 자바로 작성된 프로그램임에도 불구하고 컴퓨터마다 결과가 다를 수 있다.
- 이러한 차이를 없애기 위해 성능은 다소 포기하는 대신, 어떤 OS에 실행되어도 항상 같은 결과를 얻도록 Math클래스를 새로 작성한 것이 StrictMath클래스이다.

## 래퍼(Wrapper)클래스
자바에서는 8개의 기본형을 객체로 다루지 않는데 기본형(primitive) 변수도 어쩔 수 없이 객체로 다뤄야하는 경우가 있는데, 이 때 사용되는 것이 ***래퍼(wrapper)클래스**이다.
- 8개의 기본형을 대표하는 8개의 래퍼클래스가 있는데, 이 클래스들을 이용하면 기본형 값을 객체로 다룰 수 있다.
- 래퍼클래스의 생성자의 매개변수로 문자열을 제공할 때, 각 자료형에 알맞은 문자열을 사용하지 않으면 NumberFormatException이 발생한다는 것을 주의하자!

> 래퍼클래스들은 모두 equals()가 오버라이딩되어 있어서 주소값이 아닌 객체가 가지고 있는 값을 비교한다.

### **Number클래스**
이 클래스는 추상 클래스이며, 내부적으로 숫자를 멤버변수로 갖는 래퍼 클래스들의 조상이다.
- 기본형 중에서 숫자와 관련된 래퍼클래스들은 모두 Number클래스의 자손이다.

### **문자열을 숫자로 변환하기**
- Integer.parseInt("100") : 반환값이 기본형
- Integer.valueOf("100") : 반환값이 래퍼클래스 타입

JDK1.5부터 도입된 '오토방식'기능 때문에 반환값이 기본형일 때와 래퍼클래스일 때의 차이가 없어져서 구별없이 'valueOf()'를 쓰는 것도 괜찮다. (참고로 성능은 valueOf()가 조금 더 느리다.)

### **오토박싱 & 언박싱(autoboxing & unboxing)**
기본형 값을 래퍼클래스의 객체로 자동 변환해주는 것을 '오토박싱(autoboxing)'이라고 하고, 반대로 변환하는 것을 '언박싱(unboxing)'이라고 한다.
