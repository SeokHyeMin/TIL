# 람다식(Lamda expression)
람다식의 도입으로 인해, 자바는 객체지향언어인 동시에 함수형 언어가 되었다.

람다식이 무엇인지 알아보도록 하자.

## 람다식이란?
람다식(Lamda expression)은 간단히 말해서 메서드를 하나의 '식(expression)'으로 표현한 것이다.
- 메서드를 람다식으로 표현하면 메서드의 이름과 반환값이 없어지므로, 람다식을 **익명함수**라고도 한다.

## 람다식 작성하기
람다식은 '익명함수'답게 메서드에서 이름과 반환타입을 제거하고 매개변수 선언부와 몸통{} 사이에 '->'을 추가한다.
~~~java
    int max(int a, int b){
        return a > b ? a : b;
    }
~~~
위의 코드를 람다식으로 변경하면 아래와 같이 나타낼 수 있다.
~~~java
    (int a, int b) -> {return a > b ? a : b;}
~~~
- **반환값이 있는 메서드의 경우, return문 대신에 '식'으로 대신할 수 있다.**
~~~java
    (int a, int b) -> a > b ? a : b
    //이 때 문장이 아닌 '식'이므로 끝에 ';'을 붙이지 않는다.
~~~
- 람다식에 선언된 매개변수의 타입은 추론이 가능한 경우 생략할 수 있으며, 대부분의 경우에 생략 가능하다.
- 람다식에 반환타입이 없는 이유도 항상 추론이 가능하기 때문이다.
~~~java
    (a, b) -> a > b ? a : b
~~~

## 함수형 인터페이스
하나의 메서드가 선언된 인터페이스를 정의해서 람다식을 다루는 것은 기존의 자바 규칙들을 어기지 않으면서도 자연스럽다.
- 그렇기 때문에, 인터페이스를 통해 람다식을 다루기로 결정하였다.
- **람다식을 다루기 위한 인터페이스를 함수형 인터페이스(functional interface)라고 부르기로 했다.**
~~~java
    @FunctionalInterface
    interface MyFunction{ //함수형 인터페이스 MyFunction을 정의
        public abstract int max(int a, int b)
    }
~~~
- 단, 함수형 인터페이스에는 오직 하나의 추상 메서드만 정의되어 있어야 한다는 제약이 있다.
- 그래야 람다식과 인터페이스의 메서드가 1:1로 연결될 수 있기 때문이다.
- 반면에 static 메서드와 default메서드 개수에는 제약이 없다.

📌 @FunctionalInterface을 붙이면, 컴파일러가 함수형 인터페이스를 올바르게 정의하였는지 확인해주므로, 꼭 붙이도록 하자.

### **함수형 인터페이스의 타입의 매개변수와 반환타입**
함수형 인터페이스가 아래와 같이 정의되어 있을 때
~~~java
    @FunctionalInterface
    interface MyFunction{ //함수형 인터페이스 MyFunction을 정의
        void myMethod(); //추상 메서드
    }
~~~
- 메서드의 매개변수가 MyFunction타입이라면, 아래와 같이 이 메서드를 호출 할 때 람다식을 참조하는 참조변수를 매개변수로 지정해야한다.
~~~java
    void eMethod(MyFunction f){ //매개변수의 타입이 함수형 인터페이스인 임의의 메서드 작성
        f.myMethod(); //MyFunction에 정의된 메서드를 호출
    }

    .....

    MyFunction f = () - > System.out.println("람다식 작성");
    aMethod(f); //람다식을 참조하는 참조변수를 매개변수로

    //또는 참조변수 없이 직접 람다식을 매개변수로 지정하는 것도 가능하다.
     aMethod(() - > System.out.println("람다식 작성"));
~~~
이렇게 람다식을 참조변수로 다룰 수 있다는 것은 메서드를 통해 람다식을 주고받을 수 있다는 것을 의미한다.

### **람다식의 타입과 형변환**
함수형 인터페이스로 람다식을 참조할 수 있는 것일 뿐, 람다식의 타입이 함수형 인터페이스의 타입과 일치하는 것은 아니다.
- 람다식은 익명객체이며, 익명객체는 타입이 없다.(컴파일러가 임의로 이름을 정하기 때문에 알 수 없다.)
- 그래서 대입 연산자의 양변 타입을 일치시키기 위해서 아래와 같이 형변환이 필요하다.
~~~java
    MyFunction f = (MyFunction) (() -> {}); //양변의 타입이 다르기 때문에 형변환이 필요하다.
~~~
- 이러한 형변환은 생략이 가능하며, 람다식은 함수형 인터페이스로만 형변환이 가능하다.
- 굳이 Object타입으로 형변환을 하고 싶다면 위와 같이 함수형 인터페이스로 형변환한 후 한번 더 Object 타입으로 형변환 해주어야한다.

### **외부 변수를 참조하는 람다식**
람다식 내에서 참조하는 지역변수는 final이 붙지 않았어도 상수로 간주된다.
- 람다식 내에서 지역변수를 참조하고 있다면 람다식 내에서나 다른 곳 어디에서도 이 변수들의 값을 변경하는 일은 허용되지 않는다.

### **java.util.function패키지**
java.util.function패키지에 일반적으로 자주쓰이는 형식의 메서드를 함수형 인터페이스로 미리 정의 해놓았다.
- 매번 새로운 함수형 인터페이스를 정의하지 말고, 가능하면 이 패키지의 인터페이스를 활용하는 것이 좋다.

## 메서드 참조
람다식이 하나의 메서드만 호출하는 경우에는 '메서드 참조(method reference)'라는 방법으로 람다식을 간략히 할 수 있다.
~~~java
    Function<String, Integer> f = (String s) -> Integer.parseInt(s);
~~~
위와 같이 작성된 람닷ㄱ을 메서드 참조로 나타내면?
~~~java
    Function<String, String> f = Integer::parseInt;
~~~
- 위 메서드 참조에서 람다식의 일부가 생략된 모습을 볼 수 있다.
- 컴파일러는 생략된 부분을 우변의 **parseInt**메서드의 선언부로부터, 또는 좌변의 **Function**인터페이스에 지정된 지네릭스 타입으로부터 쉽게 알아낼 수 있다.

람다식을 메서드 참조로 바꾼 예시
~~~java
    BiFunction<String, String, Boolean> f = (s1, s2) -> s1.equals(s2);

    //메서드 참조
    BinFunction<String, String, Boolean> f = String::equals;
~~~

#### **이미 생성된 객체의 메서드를 람다식에서 사용하는 경우에는 클래스 이름 대신 그 객체의 참조변수를 적어줘야한다.**
~~~java
    MyClass obj = new MyClass();
    Function<String, Boolean> f = (x) -> obj.equals(); //람다식
    Function<String, Boolean> f = obj::equals; //메서드 참조
~~~

> 하나의 메서드만 호출하는 람다식은 '클래스이름::메서드이름' 또는 '참조변수::메서드이름'으로 바꿀 수 있다.

### **생성자의 메서드 참조**
생성자를 호출하는 람다식도 메서드 참조로 변환할 수 있다.

~~~java
    Supplier<MyClass> s = () -> new MyClass(); //람다식
    Supplier<MyClass> s = MyClass::new; //메서드 참조
~~~

그리고 배열을 생성할 때는 아래와 같이 하면 된다.
~~~java
    Function<Integer, int[]> f = x -> new int[x]; //람다식
    Function<Integer, int[]> f= int[]::new; //메서드 참조
~~~

📌 메서드 참조는 람다식을 마치 static변수처럼 다룰 수 있게 해주며, 코드를 간략히 하는데 유용하므로 많이 사용된다.

<hr>


<br>

# 스트림(Stream)
## 스트림이란?
스트림은 데이터소스를 추상화하고, 데이터를 다루는데 자주 사용되는 메서드들을 정의해 놓았다.
- 데이터소스를 추상화하였다는 것은, 데이터 소스가 무엇이던 간에 같은 방식으로 다룰 수 있게 되었다는 것과 코드의 재사용성이 높아진다는 것을 의미한다.
- 스트림을 이용하면, 배열이나 컬렉션뿐만 아니라 파일에 저장된 데이터도 모두 같은 방식으로 다룰 수 있다.
~~~java
    String[] strArr = {"aaa","ddd","ccc"};
    List<String> strList = Arrays.asList(strArr);

    //위의 데이터 소스를 기반으로 하는 스트림을 생성하자.
    Stream<String> strStream = strList.stream(); //스트림을 생성

    //이 스트림으로 데이터소스의 데이터를 읽어서 정렬하고 화면에 출력해보자.
    strSteam.sorted().forEach(System.out::println);

    //스트림을 사용하지 않고 코드를 작성했다면 아래와 같다.
    Collections.sort(strList);

    for(String str : strList)
        System.out.println(str);
~~~
코드로 작성해본것 처럼 스트림을 사용한 코드가 간결하고 이해하기 쉬우며 재사용성도 높다는 것을 알 수 있다.


### **스트림은 데이터 소스를 변경하지 않는다.**
그리고 스트림은 데이터 소스로부터 데이터를 읽기만할 뿐, 데이터 소스를 변경하지 않는다는 차이가 있다.
- 필요하다면, 정렬된 결과를 컬렉션이나 배열에 담아서 반환할 수도 있다.

### **스트림은 일회용이다.**
스트림은 Iterator처럼 일회용이다. Iterator로 컬렉션의 요소를 모두 읽고 나면 다시 사용할 수 없는 것처럼, 스트림도 한 번 사용하면 닫혀서 다시 사용할 수 없다. 필요하다면 스트림을 다시 생성해야한다.

### **스트림은 작업을 내부 반복으로 처리한다.**
스트림을 이용한 작업이 간결할 수 있는 비결중의 하나가 바로 '내부 반복'이다.
- 내부 반복이라는 것은 반복문을 메서드의 내부에 숨길 수 있다는 것을 의미한다.
- forEach()는 스트림에 정의된 메서드 중의 하나로 매개변수에 대입된 람다식을 데이터 소스의 모든 요소에 적용한다.
~~~java
    for(String str : strList)
        System.out.println(str);

    //메서드 참조 System.out::println를 람다식으로 표현하면
    //(str) -> System.out.println(str)과 같다.
    stream.forEach(System.out::println);
~~~

## 스트림의 연산
스트림이 제공하는 다양한 연산을 이용해서 복잡한 작업들을 간단히 처리할 수 있다.
- 마치 데이터베이스에 SELECT문으로 질의(쿼리, query)하는 것과 같은 느낌이다.
- 중간연산 : 연산결과가 스트림인 연산, 스트림에 연속해서 중간연산할 수 있다.
- 최종연산 : 연산결과가 스트림이 아닌 연산, 스트림의 요소를 소모하므로 단 한번만 가능하다.

### **지연된 연산**
스트림에서 한 가지 중요한 점은 최종 연산이 수행되기 전까지는 중간연산이 수행되지 않는다는 것이다.
- 중간 연산을 호출해도 즉각적인 연산이 수행되는 것이 아니다.
- 중간 연산을 호출하는 것은 단지 어떤 작업이 수행되어야하는지를 지정해주는 것일 뿐이다.
> 최종연산이 수행되어야 비로소 스트림의 요소들이 중간 연산을 거쳐 최종 연산에서 소모된다.

### **병렬 스트림**
스트림으로 데이터를 다룰 때의 장점 중 하나가 바로 병렬 처리가 쉽다는 것이다.
- 병렬 스트림은 내부적으로 fork&join프레임워크를 이용해서 자동적으로 연산을 병렬로 수행한다.
- 스트림에 parallel()이라는 메서드를 호출해서 병렬로 연산을 수행하도록 지시하면 될 뿐이다.
- 반대로 병렬로 처리되지 않게 하려면 sequential()을 호출하면 된다.  
    - 참고로 모든 스트림은 기본적으로 병렬 스트림이 아니므로 sequential()을 호출할 필요가 없고, parallel()을 호출한 것을 취소할 때만 사용한다.

    