## 연관관계 매핑
- 방향(Direct) : 단방향, 양방향
- 다중성(Multiplicity) : 다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M) 
- 연관관계 주인(Owner) : 객체 양방향 연관관계는 주인이 필요하다.

- 객체를 테이블에 맞추어 모델링하면, 외래 키 식별자를 직접 다루게 되고, 식별자로 조회하는 등 객체 지향적인 방법이 아니게 된다.
- 객체를 테이블에 맞추어 데이터 중심으로 모델링하면, 협력 관계를 만들 수 없다.
    - 테이블은 외래 키로 조인을 사용해서 연관된 테이블을 찾는다.
    - 하지만 객체는 참조를 사용해서 연관된 객체를 찾는다.
    - 테이블과 객체 사이에 이러한 큰 간격이 있다.

#### 📌 객체 연관관계를 사용하여 객체 지향 모델링을 할 수 있다.

- 객체의 참조와 테이블의 외래키를 매핑한다.

#### 양방향 연관관계와 연관관계의 주인
- **객체의 양방향 연관관계는 서로 다른 단방향 연관관계가 2개 있는 것**이라고 볼 수 있다.
- 객체를 양방향으로 참조하려면 단방향 연관관계를 2개 만들어야 하는 것이다.
- **테이블**은 외래 키 하나로 두 테이블의 연관관계를 관리한다.
- 양방향 매핑시 연관관계의 주인에 항상 값을 입력해야한다.(항상 양쪽 다 값을 입력하도록 하자)


#### 📌 양방향 매핑 규칙
- 객체의 두 관계중 하나를 연관관계의 주인으로 지정해야한다.
- **연관관계의 주인만이 외래 키를 관리할 수 있다.(등록, 수정)**
- 주인이 아닌 쪽은 읽기만 가능하다.
- 주인은 mappedBy 속성을 사용하지 않으며, 주인이 아니면 mappedBy 속성으로 주인을 지정한다.
~~~java
    @OneToMany(mappedBy = "team") 
    List<Member> members = new ArrayList<Member>();
~~~

#### 누구를 연관관계 주인으로 지정해야 할까?
- 답은 **외래 키가 있는 곳을 주인**으로 지정해야한다.
- 비즈니스 로직을 기준으로 연관관계의 주인을 선택하면 안된다!! 연관관계의 주인은 외래 키의 위치를 기준으로 선택해야한다.

#### 📌 **핵심은 단방향 매핑으로 설계를 잘하는 것이 중요하다, 필요 시 양방향 매핑 연관관계를 추가하도록 하자.**
<hr>

#### 다대일 [N:1]
- @ManyToOne
- 다대일 단반향
    -  가장 많이 사용하는 연관관계
- 다대일 양방향
    - 외래 키가 있는 쪽이 연관관계의 주인이며, 양쪽을 서로 참조하도록 개발한다.

#### 일대다 [1:N]
- @OneToMany
- 일대다 단방향
    - 일대다에서 **일(1)이 연관관계의 주인이 된다.**
    - 테이블의 일대다 관계는 항상 **다(N)쪽에 외래키**가 있다.
    - 중요한 점은 @JoinColumn을 사용하지 않으면 조인테이블 방식을 사용하므로, 즉 중간에 테이블을 하나 추가하므로 꼭 사용해야한다.<br>

📌 **엔티티가 관리하는 외래 키가 다른 테이블에 있으므로 연관관계 관리를 위해 추가로 UPDATE SQL을 실행해야 하므로 일대다 단반향 매핑보다는 다대일 양방향 매핑을 사용하는 것이 좋다.**
- 일대다 양방향 또한 읽기 전용 필드를 사용해서 양방향 처럼 사용할 수 있지만, 다대일 양방향을 사용하는 것을 권장한다.

#### 일대일 [1:1]
- @OneToOne
- 일대일 관계는 그 반대도 일대일이다.
- 외래키에 데이터 베이스 유니크 제약조건을 추가해야한다.
- 주 테이블이나 대상 테이블 중에 외래 키를 선택 가능하다.
    - **주 테이블에 외래 키**
        - 주 테이블에 외래 키 단반향 매핑은 다대일 단방향 매핑과 유사하다.
        - 주 테이블에 외래 키 양방향 매핑은 장단점은 있지만 개발자의 경우 주 테이블에 있는 경우가 조금 더 유리하다. 주 테이블에서 조회할 경우가 많기 때문이다.
        - **주 테이블에 외래 키 양방향은 외래 키가 있는 곳이 연관관계의 주인이다.**
        - 반대편은 mappedBy 적용해야한다.
        - JPA 매핑은 편리하나 값이 없으면 외래 키에 null이 허용된다.
    - **대상 테이블에 외래 키**
        - 대상 테이블에 외래 키 단방향 관계는 JPA에서 지원하지 않는다.
        - 대상 테이블에 외래 키 양방향은 대상 테이블에 외래 키가 존재한다.
            - 장점은 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조를 유지한다.

#### 다대다[N:N]
- @ManyToMany 
- @JoinTable로 연결 테이블 지정
- 단방향, 양방향 둘 다 가능
- 하지만 가급적 실무에서 사용하지 말자.

<hr>

### 상속관계 매핑
- 객체의 상속과 구조와 DB의 슈퍼타입 서브타입 관계를 매핑한다.
- 슈퍼타입 서브파입 논리 모델을 실제 물리 모델로 구현하는 방법
1. 각각 테이블로 변환 : 조인 전략(비즈니스 적으로 중요하거나 복잡한 경우 사용)
2. 통합 테이블로 변환 : 단일 테이블 전략(단순한 경우 주로 사용)
3. 서브타입 테이블로 변환 : 구현 클래스마다 테이블 전략

- @Inheritance(strategy=InheritanceType.???) : 부모클래스에서 어노테이션으로 타입을 정할 수 있다.
    - JOINED : 조인 전략
    - SINGLE_TABLE : 단일 테이블 전략
    - TABLE_PER_CLASS : 구현 클래스마다 테이블 전략
- @DiscriminatorColumn(name="DTYPE")
    - 컬럼명은 DTYPE말고 다른것으로 바꿀 수 있다.
    - 엔티티명이 들어간다.
    - 항상 작성하는 것이 구분하기 쉽기 때문에 작성하는 것을 추천한다.
- @DiscriminatorVlaue("???")
    - 엔티티 이름은 클래스 값과 동일(기본값)하지만 ???에 원하는 값을 넣어 바꿀 수도 있다.


#### **조인전략**
- 테이블 정규화, 외래 키 참조 무결성 제약조건을 활용가능하며, 저장공간도 효율적으로 사용할 수 있다.
- 하지만 조회시에 조인을 많이 사용하며, 이로인해 성능이 저하된다.
- 조회 쿼리 또한 복잡하며, 데이터 저장 시에 INSERT SQL을 2번 호출한다는 단점도 있다.

#### **단일 테이블 전략**
- 조인이 필요없기 때문에 일반적으로 조회 성능이 빠르고, 조회 쿼리가 단순하다.
- 하지만 자식 엔티티가 매핑한 컬럼은 모두 null을 허용하는게 치명적인 단점이고, 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다.
- 임계점을 넘으면 조회 성능이 오히려 느려질 수 있지만 흔한 일은 아니다.

#### **구현 클래스마다 테이블 전략**
- 서브 타입을 명확하게 구분해서 처리할 때 효과적이고, not null 제약조건을 사용가능하다.
- 하지만 자식테이블을 통합해서 쿼리하기도 어렵고, 여러 자식 테이블을 함께 조회할 때 성능이 느리다.
- 일반적으로 이 방법은 추천하지 않는다.
<hr>

### @MappedSuperclass
- 공통 매핑 정보가 필요할 때 사용한다.
- 부모 클래스를 상속 받는 자식 클래스에 매핑 정보만 제공한다.
- 조회와 검색을 불가능하다.
- 직접 생성해서 사용할 일은 없으므로 추상 클래스를 권장한다.
- 테이블과 관계 없고, 단순히 엔티티가 공통으로 사용하는 매핑 정보를 모으는 역할이다.
- 주로 등록일이나 수정일, 등등 전체 엔티티에서 공통으로 적용하는 정보를 모을 때 사용한다.

📌 참고 : @Entity 클래스는 엔티티나 @MappedSuperclass로 지정한 클래스만 상속가능하다.