## 프록시
- Member 엔티티를 조회할 때 Team도 함께 조회해야 할까?
- 실제로 필요한 비즈니스 로직에 따라 다르다.
- 비즈니스 로직에서 필요하지 않을 경우에는 항상 Team을 함께 가져와서 사용할 필요는 없다.(낭비)
- JPA는 낭비를 하지 않기 위해, 지연로딩과 프록시라는 개념으로 해결한다.

#### **프록시 기초**
- JPA는 em.find()메서드가 있지만 em.getReference()라는 메서드도 제공한다.
- em.find() 는 DB를 통해서 실제 엔티티 객체를 조회하는 메서드이다.
- em.getReference() 는 DB의 조회를 미루는 가짜(프록시) 엔티티 객체를 조회하는 메서드이다.
- em.find()로 멤버를 조회한다면 데이터 베이스에 쿼리가 바로 나간다.
- em.getReference()로 멤버를 조회하면, 실제로 필요한 시점에 데이터베이스에 쿼리가 나간다.

#### **프록시 특징**
- 프록시는 실제 클래스를 상속 받아서 만들어 진다.
    - 하이버네이트가 내부적으로 상속받아서 만든다.
- 실제 클래스와 겉 모양이 같다.
- 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 된다.
- 프록시 객체는 실제 객체의 참조(target)를 보관한다.
- 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드 호출.

#### **프록시 객체의 초기화**
~~~
    Member member = em.getReference(Member.class, member.getId());
    member.getName();
~~~
1. 처음에 em.getReference로 프록시 객체를 가져온 뒤, getName() 메서드를 호출하면 멤버 프록시 객체에 처음에 target값이 존재하지 않는다.
2. JPA가 영속성 컨텍스트에 초기화 요청을한다.
3. 영속성 컨텍스트가 DB에서 조회한 뒤
4. 실제 Entity를 생성해준다.
5. 그리고 프록시 객체가 가지고 있는 target(실제 Member)의 getName()을 호출(target.getName())한 결과를 받는다.
6. 프록시 객체에 target이 할당되고 난 후에는 프록시 객체의 초기화 동작은 없어도 된다.

#### **📌프록시 특징 총 정리**
- 프록시 객체는 처음 사용할 때 한 번만 초기화 한다.
- 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다. 초기화 되면 프록시 객체를 통해서 실제 엔티티에 접근이 가능하다.
    - target에 값이 채워지는 것일 뿐이다.
- 프록시 객체는 원본 엔티티를 상속받는 것이기 때문에 따라서 타입 체크시 주의해야한다.
**(==으로 하면 비교실패, 대신 instance of를 사용해야 한다.)**
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티를 반환한다.
    - 영속성 컨텍스트에 이미 올려놓은 객체를 굳이 다시 프록시로 감싸 반환할 이유가 없기 때문이다.
**실무에서 많이 발생하는 문제**
- 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하게 되면 문제가 발생한다.
    - 하이버네이트는 org.hibernate.LazyInitializationException 예외를 터뜨린다.


